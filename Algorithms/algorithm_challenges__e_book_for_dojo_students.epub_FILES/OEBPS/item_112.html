<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_52"><span>Objects and Classes</span></h2><p class="Normal1"><span>A </span><span style="font-weight:bold">class definition </span><span>is like a blueprint of a complex machine, from which many copies can be made. </span><span>Actually</span><span>,</span><span> constructing a machine is a separate step. </span><span>Likewise, </span><span style="font-style:italic">declaring</span><span> a class merely informs </span><span>us</span><span> of that blueprint; </span><span>actual</span><span> objects must be individually constructed. In JavaScript, class declarations take the form of functions called </span><span style="font-style:italic">object constructors</span><span> – when </span><span>called, they create an </span><span style="font-weight:bold">object</span><span> </span><span>for </span><span>the caller. An object is </span><span>an instance of the class,</span><span> brought to life, just like a physical copy of the </span><span>ideas in the </span><span>blueprint. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>Not all machines are complex</span><span>;</span><span> not all objects complicated. However, code can add </span><span>or</span><span> remove </span><span>attributes</span><span> of objects on the fly, so</span><span> this makes them different than a boolean or number which always occupies</span><span> the same amount of </span><span>memory </span><span>space. Why does this matter?</span><span> </span><span>I</span><span>f you have debugged JavaScript code in the browser, you </span><span>may </span><span>understand the </span><span style="font-style:italic">call stack</span><span> idea</span><span>. This series of function calls led the computer to where it is right now. </span><span>Whenever the currently running </span><span>function returns, the JavaScript runtime look</span><span>s</span><span> to th</span><span>e</span><span> call stack to help it </span><span>“</span><span>remember</span><span>”</span><span> which function it came from, as well as the state of all local variables when it called into another function. The runtime stores variables in the stack </span><span>while</span><span> changing execution to another function. Setting aside </span><span>call stack </span><span>space for booleans and numbers is easy </span><span>–</span><span> regardless of value, numbers occupy a 64-bit </span><span>memory </span><span>chunk. However, objects are tricky: JavaScript cannot determine </span><span style="font-style:italic">a priori</span><span> how much space to set aside for objects. </span><span>Ho</span><span>w can it quickly construct a call stack?</span><span> </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>The answer is that objects are created using a common chunk of memory set aside for</span><span> variable-sized allocations</span><span>. This memory is called the </span><span style="font-style:italic">heap</span><span>, and it is used for any </span><span>unpredictable memory needs</span><span>. When the system look</span><span>s</span><span> at your </span><span>‘</span><span>blueprint</span><span>’</span><span> and construct</span><span>s</span><span> a </span><span>‘</span><span>machine</span><span>’</span><span> </span><span>corresponding</span><span> to those plans, </span><span>it goes to the </span><span style="text-decoration:underline">heap</span><span> </span><span>and sets aside </span><span>space for all </span><span>that object’s</span><span> attributes and functions. </span><span>If the</span><span> object needs more space, it expand</span><span>s</span><span> into adjacent </span><span>heap </span><span>memory. During normal operation, the heap is wide-open for large and small allocations. </span><span>T</span><span>he call stack is apart</span><span>ment space in a high-rise tower;</span><span> the heap is Montana. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span>When you create an object and store it in a local </span><span class="CodeSnippet" style="font-family:Times, serif">var</span><span>, the system doesn</span><span>’</span><span>t put the object in that memory slot the way it does for a number or a boolean. </span><span>It puts </span><span>a </span><span style="font-style:italic">reference</span><span> to that </span><span>heap location into your local </span><span class="CodeSnippet" style="font-family:Times, serif">var</span><span>. References (called </span><span style="text-decoration:underline">pointers</span><span>) are fixed-size, so this enables the runtime do its stack magic. A pointer represents an object</span><span>’</span><span>s location in memory, but you can think of it as an object</span><span>’</span><span>s contact info</span><span>: its </span><span>email address. </span><span>True to its name, a</span><span> </span><span>pointer</span><span> </span><span style="font-style:italic">points</span><span> to where the object is found. If you have information to retrieve from (or store to) an object, you </span><span>“</span><span>go there</span><span>”</span><span> by </span><span>de</span><span>referencing that pointer, followed by the attribute you want within the object. This could look like </span><span style="font-family:Times, serif; font-weight:bold">myProject.name</span><span> or </span><span style="font-family:Times, serif; font-weight:bold">myQuizzes[3]</span><span> or even </span><span style="font-family:Times, serif; font-weight:bold">getAverage(myArr)</span><span>. Yes, </span><span style="text-decoration:underline">arrays</span><span>, </span><span style="text-decoration:underline">strings</span><span> and even </span><span style="text-decoration:underline">functions</span><span> are objects </span><span>–</span><span> </span><span>de</span><span>referenced by </span><span style="font-weight:bold">.</span><span> or </span><span style="font-weight:bold">[</span><span> or </span><span style="font-weight:bold">(</span><span> .</span><span> </span></p><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 5</span><span> – Linked Lists </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>