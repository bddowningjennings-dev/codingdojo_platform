<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_100"><span>Full</span><span> Trees</span><span> and Complete Trees</span></h2><p><span>We have previously discussed whether a BST is balanced. A BST that is roughly balanced retains its excellent performance, whereas if it grows unbalanced, its performance can rapidly deteriorate. Two types of trees that take this to the extreme are </span><span style="font-weight:bold">Complete</span><span> and </span><span style="font-weight:bold">Full</span><span> trees. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span style="font-style:italic">Full</span><span> trees are perfectly balanced. If each step further away from the root node is represented by a </span><span style="font-style:italic">layer</span><span> of nodes at that level, then every layer that exists in the </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> is entirely filled with nodes. In other words, each leaf node’s path to the root has the same length. As a side effect, every full BST contains a number of nodes that is one less than an integer power of two (i.e. 1, 3, 7, 15, 31, 63, etc). A </span><span style="font-style:italic">full</span><span> tree is the </span><span>strictest</span><span> type of balanced tree possible! </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span style="font-style:italic">Complete</span><span> trees are just like full trees, with one possible exception. In a complete tree, it is acceptable for the bottom layer to be less than entirely filled, </span><span style="text-decoration:underline">so long as all nodes in that layer are as leftmost as possible</span><span>. </span><span>Completeness is a superset of fullness; that is, all full trees are also considered complete. A </span><span style="font-style:italic">complete </span><span>Binary Tree is as balanced as a tree with that number of nodes can be. Completeness is also </span><span style="font-style:italic">very</span><span> expensive to maintain, and for this reason complete </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>s</span><span> are rarely used in production, since the costs of keeping a </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> truly complete are </span><span style="font-style:italic">much</span><span> higher than the costs of adjusting it only when it becomes significantly unbalanced. In practice, complete binary trees are normally only seen in non-</span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> situations, such as the ‘Binary Tree projection’ we see in the Heap data structure, whe</span><span>re we interpret the underlying a</span><span>rray index positions as </span><span class="CodeSnippet" style="font-family:Times, serif">BT</span><span class="CodeSnippet" style="font-family:Times, serif">Node</span><span>s </span><span>in a hypot</span><span>hetical binary t</span><span>ree. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: I</span><span style="font-size:0.86em">s Full</span></p><p style="line-height:115%"><span>Chekov</span><span> keeps his data perfectly clean. I mean, </span><span style="font-style:italic">per-</span><span style="font-style:italic">fect</span><span style="font-style:italic">-</span><span style="font-style:italic">ly</span><span style="font-style:italic"> </span><span>clean. He doesn’t just keep them balanced. He keeps a </span><span style="font-style:italic">full </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> at all times. Given a pointer to a </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> object, return whether the </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> is a </span><span style="font-style:italic">full</span><span> tree. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST</span><span style="font-size:0.86em">: Is</span><span style="font-size:0.86em"> </span><span style="font-size:0.86em">Complete</span></p><p style="line-height:115%"><span>His cousin </span><span>Pikov</span><span> is a bit less neurotic. He does still keep everything highly balanced. He keeps his </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>s complete at all times. Given a </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> object, return whether that </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> is </span><span style="font-style:italic">complete</span><span>. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST Discussion</span></p><p style="line-height:115%"><span>What is the advantage of </span><span>Chekov’s </span><span>approach? What is the advantage of </span><span>Pikov’s</span><span> approach? What about their crazy uncle </span><span>Dropov</span><span>, who never balances his </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>s at all – is he being negligent? Maybe there isn’t a single ‘right’ answer</span><span>. S</span><span>o how do we know what approach is best for the situation at hand? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 15</span><span> – Trees, Part II</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>