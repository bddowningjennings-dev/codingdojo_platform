<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h1 id="navPoint_97"><img src="item_067.png" width="216" height="65" alt="" style="float:left; margin:0pt 9pt" /><span>Chapter 14</span><span> – Hashes</span><span> </span></h1><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="line-height:115%"><span>Have you ever wondered how </span><span style="font-style:italic">key-value</span><span> data structures work? You have already worked with these, as they are prominent in most programming languages. Regardless of the number of key-value pairs, they can “instantly” retrieve values (</span><span class="CodeSnippet" style="font-family:Times, serif">O(1)</span><span> </span><span>run-time perf!). How do they do this, even when highly loaded? </span></p><p><span>&#xa0;</span></p><p><span>This chapter we investigate a new data structure – one used “under the covers” to construct the collection of unordered key-value pairs known in PHP as </span><span style="text-decoration:underline">associative arrays</span><span>, in Python / Swift / C# as </span><span style="text-decoration:underline">dictionaries</span><span>, in JS as </span><span style="text-decoration:underline">objects</span><span> (minus methods, prototypes, etc.), and in C++ STL as </span><span style="text-decoration:underline">maps</span><span>. Ruby and Java have the most appropriate name for this unordered key-value data structure: Ruby calls them </span><span style="text-decoration:underline">hashes</span><span>, and Java calls them </span><span style="text-decoration:underline">hashtables</span><span>. Why? Because a </span><span style="font-style:italic">hash</span><span> function gives this data structure its quick-check, quick-retrieval feature, even when containing lots of data. </span></p><p><span>&#xa0;</span></p><p><span>Consider the </span><span style="font-style:italic">array</span><span> data structure, which is quick-retrieval. Every array element can be immediately reached with a single index dereference. </span><span style="font-style:italic">If you know the index</span><span>, you can directly access its value: </span><span style="font-family:Times, serif; font-weight:bold">arr[idx]</span><span>. This strength is also its main weakness: you </span><span style="font-style:italic">must</span><span> know index in order to access element. </span></p><p><span>&#xa0;</span></p><p><span>The word “associative” is used with these because they </span><span style="font-style:italic">associate</span><span> a certain key with a certain value. If we use an associative array to track a specific user, we might have this: </span><span style="font-family:Times, serif; font-weight:bold">{ name: "Marino", age: 27, IQ: 144, languages: ['Italian', 'English'], height: 181 }</span><span>. Here, we directly access the user’s age (for example) by referencing the key: </span><span style="font-family:Times, serif; font-weight:bold">myUser['age']</span><span> or </span><span style="font-family:Times, serif; font-weight:bold">myUser.age</span><span>. If associative arrays didn’t exist yet, how would we construct them using only traditional (numerical) arrays? </span></p><p><span>&#xa0;</span></p><p><span>Traditional arrays associate </span><span style="font-style:italic">numerical</span><span> indices with values. The index is a key. Continuing our example to store user information in an array </span><span style="font-family:Times, serif; font-weight:bold">["Marino",27,144,['Italian','English'],181]</span><span>, we can quickly access user age (27) or name (“Marino”), because we know the one and only one place in the array where we always find user age (at index </span><span style="font-family:Times, serif; font-weight:bold">[1]</span><span>) or name (at index </span><span style="font-family:Times, serif; font-weight:bold">[0]</span><span>). We get the benefit of quick-retrieval only if 1) for each piece of information, we have a specific index where we always store it, and 2) we remember that decision (e.g. that </span><span style="font-family:Times, serif; font-weight:bold">[0]</span><span> corresponds to name, </span><span style="font-family:Times, serif; font-weight:bold">[1]</span><span> to age, etc). Can we make this automatic, while retaining quick-retrieval? Yes. A </span><span style="font-style:italic">hash function </span><span>can automatically pick indices for us. </span></p><p><span>&#xa0;</span></p><p><span>Hash functions take inputs (generally strings) and generate large, seemingly random (but repeatable) numbers, called </span><span style="font-style:italic">hash codes</span><span>. To </span><span>generate a unique index for each key, we use its hash code as the index – this way each key has a reproducible index in our array where its value will be stored. Note: hash codes could be huge (or negative)</span><span>. To </span><span>fit into our array, we limit them to a manageable range. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>We solve this by constraining our array to a certain capacity, and </span><span style="font-style:italic">modulo</span><span>ing the hash codes so that they fit into that range</span><span>. To </span><span>store the key/value </span><span style="font-family:Times, serif; font-weight:bold">{ name: "Marino" }</span><span> into our ‘map’, we get the hash code of the key </span><span class="CodeSnippet" style="font-family:Times, serif">name</span><span>, </span><span style="font-family:Times, serif; font-weight:bold">mod</span><span> that hash code to get an index that fits within the capacity of our array, and save “Marino” at that index</span><span>. To </span><span>retrieve the value for key </span><span class="CodeSnippet" style="font-family:Times, serif">name</span><span>, we hash the key, </span><span style="font-family:Times, serif; font-weight:bold">mod</span><span> the hash code to get an index within bounds of our array, then retrieve value at that index. We can store vast numbers of key/value pairs and still quickly retrieve values, without iterating through keys or values </span><span style="font-style:italic; font-weight:bold">or</span><span> having to remember which index corresponds to which key. It’s a beautiful thing. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 14</span><span> – Hashes </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>We now know all we need to build the associative array data structure, also called </span><span style="font-style:italic; text-decoration:underline">unordered_map</span><span>. </span><span>It’s a </span><span style="font-weight:bold">Map</span><span>, because </span><span style="text-decoration:underline">keys map to values</span><span> (if it had single values, not </span><span>key</span><span>-</span><span>value</span><span> pairs, we call it a </span><span style="font-style:italic">set</span><span>). </span><span>It’s </span><span style="font-weight:bold">Unordered</span><span>, because (unlike BST or Queue) we do not </span><span>maintain any order or sequence for elements</span><span>. </span><span>Our</span><span> hash is sufficiently random we know nothing about keys that are hashed to </span><span>adjacent</span><span> buckets.</span></p><p><span>&#xa0;</span></p><p><span>W</span><span>ith any data structure, after creating </span><span>a</span><span> simple constructor (</span><span style="font-family:Times, serif; font-weight:bold">HashMap</span><span style="font-family:Times, serif; font-weight:bold">()</span><span>), we </span><span>build</span><span> methods for </span><span>adding data </span><span>to the structure</span><span> and for checking whether a </span><span>value</span><span> is </span><span>found</span><span> i</span><span>n the structure –</span><span> </span><span style="font-family:Times, serif; font-weight:bold">add(key, value)</span><span> and </span><span style="font-family:Times, serif; font-weight:bold">contains(key)</span><span>. </span><span>Let’s also build </span><span style="font-family:Times, serif; font-weight:bold">isEmpty()</span><span>, which suggest</span><span>s</span><span> we add</span><span> </span><span style="font-family:Times, serif; font-weight:bold">numKeys</span><span> to our constructor. </span></p><p><span>&#xa0;</span></p><p class="Normal1"><span>Here’s our flow</span><span>, where a call to </span><span style="font-weight:bold; text-decoration:underline">Add()</span><span> converts </span><span style="font-weight:bold; text-decoration:underline">Key</span><span> to </span><span style="font-weight:bold; text-decoration:underline">HashKey</span><span> to </span><span style="font-weight:bold; text-decoration:underline">ModHash</span><span>, changing the </span><span style="font-weight:bold; text-decoration:underline">Array</span><span>)</span><span>:</span></p><p class="Normal1" style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">add("myKey",42)</span><span>    </span><span style="font-family:Times, serif"></span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">myKey</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span>  </span><span style="font-family:Times, serif"></span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">-1853110172</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span style="font-family:Times, serif"></span><span>  </span><span class="CodeSnippet" style="font-family:Times, serif">2</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span style="font-family:Times, serif"></span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">[undefined,</span><span class="CodeSnippet" style="font-family:Times, serif">undefined,42</span><span class="CodeSnippet" style="font-family:Times, serif">]</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">add("aKey","foo")</span><span style="font-family:Times, serif"></span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">a</span><span class="CodeSnippet" style="font-family:Times, serif">Key</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span>    </span><span style="font-family:Times, serif"></span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">-851179773</span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span style="font-family:Times, serif"></span><span>  </span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span style="font-family:Times, serif"></span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">[undefined,"</span><span class="CodeSnippet" style="font-family:Times, serif">foo</span><span class="CodeSnippet" style="font-family:Times, serif">",</span><span class="CodeSnippet" style="font-family:Times, serif">42</span><span class="CodeSnippet" style="font-family:Times, serif">]</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Normal1"><span>Our</span><span> challenges use these reference definitions:</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">function </span><span style="font-family:Times, serif; font-weight:bold">HashMap</span><span style="font-family:Times, serif; font-weight:bold">(</span><span style="font-family:Times, serif; font-weight:bold">cap</span><span style="font-family:Times, serif; font-weight:bold">acity</span><span style="font-family:Times, serif; font-weight:bold">) {</span></p><p class="Normal1" style="text-indent:18pt"><span style="font-family:Times, serif; font-weight:bold">this.capacity = </span><span style="font-family:Times, serif; font-weight:bold">cap</span><span style="font-family:Times, serif; font-weight:bold">acity</span><span style="font-family:Times, serif; font-weight:bold">;</span></p><p class="Normal1" style="text-indent:18pt"><span style="font-family:Times, serif; font-weight:bold">this.table = [];</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">}</span></p><p class="Normal1"><span style="font-family:Consolas, monospace; font-weight:bold">&#xa0;</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">//</span><span style="font-family:Times, serif; font-weight:bold"> We u</span><span style="font-family:Times, serif; font-weight:bold">se </span><span style="font-family:Times, serif; font-weight:bold">this line</span><span style="font-family:Times, serif; font-weight:bold"> to hash a string</span><span style="font-family:Times, serif; font-weight:bold">...</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">var myHashCode = </span><span style="font-family:Times, serif; font-weight:bold">myString.hashCode()</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">// ...based on this implementation:</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">String.prototype.hashCode = function() {</span></p><p class="Normal1" style="text-indent:18pt"><span style="font-family:Times, serif; font-weight:bold">var hash = 0;</span></p><p class="Normal1" style="text-indent:18pt"><span style="font-family:Times, serif; font-weight:bold">if (this.length == 0) return hash;</span></p><p class="Normal1" style="text-indent:18pt"><span style="font-family:Times, serif; font-weight:bold">for (i = 0; i &lt; this.length; i++) {</span></p><p class="Normal1" style="margin-left:36pt"><span style="font-family:Times, serif; font-weight:bold">char = this.charCodeAt(i);</span></p><p class="Normal1" style="margin-left:36pt"><span style="font-family:Times, serif; font-weight:bold">hash = ((hash&lt;&lt;5)-hash)+char;</span></p><p class="Normal1" style="margin-left:36pt"><span style="font-family:Times, serif; font-weight:bold">hash &amp;= </span><span style="font-family:Times, serif; font-weight:bold">hash</span><span style="font-family:Times, serif; font-weight:bold">;</span><span style="font-family:Times, serif; font-weight:bold"> </span><span style="font-family:Times, serif; font-weight:bold">//Convert</span><span style="font-family:Times, serif; font-weight:bold">--&gt;</span><span style="font-family:Times, serif; font-weight:bold">32b</span><span style="font-family:Times, serif; font-weight:bold"> int</span></p><p class="Normal1" style="text-indent:18pt"><span style="font-family:Times, serif; font-weight:bold">}</span></p><p class="Normal1" style="text-indent:18pt"><span style="font-family:Times, serif; font-weight:bold">return hash;</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">}</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">// </span><span style="font-family:Times, serif; font-weight:bold">JS %</span><span style="font-family:Times, serif; font-weight:bold"> acts oddly for negatives, </span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">// </span><span style="font-family:Times, serif; font-weight:bold">so we </span><span style="font-family:Times, serif; font-weight:bold">define our own </span><span style="font-family:Times, serif; font-weight:bold">this way</span><span style="font-family:Times, serif; font-weight:bold">...</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">function mod(input, div) </span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">{ return (input % div + </span><span style="font-family:Times, serif; font-weight:bold">div</span><span style="font-family:Times, serif; font-weight:bold">) % </span><span style="font-family:Times, serif; font-weight:bold">div</span><span style="font-family:Times, serif; font-weight:bold">; }</span></p><p class="Normal1"><span style="font-family:Consolas, monospace; font-weight:bold">&#xa0;</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">// ... and we use it this way:</span></p><p class="Normal1"><span style="font-family:Times, serif; font-weight:bold">var myIdx = mod(myHashCode,</span><span style="font-family:Times, serif; font-weight:bold">arrSize);</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Hash</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> A</span><span style="font-size:0.86em">dd</span></p><p class="Normal1" style="line-height:115%"><span>Create a</span><span>n </span><span class="CodeSnippet" style="font-family:Times, serif">add(key, val)</span><span> method on </span><span class="CodeSnippet" style="font-family:Times, serif">HashMap</span><span> to add a new key and value to the map. This entails hashing key, mod</span><span>’</span><span>ing it into the size of your array, and placing the value there. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span style="font-weight:bold">Second</span><span style="font-weight:bold">:</span><span> </span><span>I</span><span>f two </span><span>values</span><span> hash to the same index, </span><span>it causes a </span><span style="font-style:italic">hash collision</span><span>.</span><span> </span><span>Then, you should use a secondary array or </span><span class="CodeSnippet" style="font-family:Times, serif">SList</span><span> instead of </span><span>overwriting (losing) val</span><span>ue</span><span>s</span><span>.</span><span> </span><span>Do you still have to worry about hash collisions</span><span> if you have a </span><span style="font-style:italic; text-decoration:underline">set</span><span>, not a </span><span style="font-style:italic; text-decoration:underline">multiset</span><span>? </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Hash</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> I</span><span style="font-size:0.86em">s Empty</span></p><p style="line-height:115%"><span>Dude, what if you use a </span><span class="CodeSnippet" style="font-family:Times, serif">HashMap</span><span> to find your</span><span> </span><span style="font-style:italic">hash cache</span><span>, but someone stole it all? Bummer. Return</span><span> whether </span><span>this</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">HashMap</span><span> is empty. </span><span>This is a </span><span>one-liner</span><span> but </span><span>require</span><span>s</span><span> changes elsewhere.</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Hash</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> F</span><span style="font-size:0.79em">ind</span><span style="font-size:0.86em"> Key</span></p><p class="Normal1" style="line-height:115%"><span>Create a </span><span class="CodeSnippet" style="font-family:Times, serif">find(key)</span><span> </span><span>method </span><span>to return</span><span> </span><span>value for </span><span>given key. If </span><span>key is not found,</span><span> return </span><span class="CodeSnippet" style="font-family:Times, serif">null</span><span>.</span></p><p class="Normal1"><span>&#xa0;</span></p><p style="line-height:115%"><span style="font-weight:bold">Second</span><span style="font-weight:bold">:</span><span> if you altered </span><span style="font-family:Times, serif; font-weight:bold">add(</span><span style="font-family:Times, serif; font-weight:bold">key,val</span><span style="font-family:Times, serif; font-weight:bold">)</span><span> to handle collisions, extend </span><span class="CodeSnippet" style="font-family:Times, serif">find(key)</span><span> </span><span>accordingly.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 14</span><span> – Hashes </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="line-height:115%"><span>So far, our</span><span> </span><span style="font-style:italic">hash </span><span>structure can add </span><span>and retrieve </span><span>key-value</span><span>s</span><span>, and indicate </span><span style="font-style:italic">emptiness</span><span>. T</span><span>hese correspond to</span><span> classic methods</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">add</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">contains</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">isEmpty</span><span>. What about the others (</span><span class="CodeSnippet" style="font-family:Times, serif">remove</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">size</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">front</span><span>)? </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>First, </span><span class="CodeSnippet" style="font-family:Times, serif">front</span><span style="font-style:italic"> </span><span>has no meaning in a key-value data structure. We don’t keep keys or values in any order, other than how our hash code handles them – and this is not an order we expose to the user, since we might change our hash someday. Second, </span><span class="CodeSnippet" style="font-family:Times, serif">size</span><span> is only partially relevant in a key-value data structure. A hash is similar to a</span><span> circular queue</span><span>:</span><span> it has</span><span> </span><span style="font-style:italic">capacity</span><span> (the unchanging number of available buckets),</span><span> as well as </span><span>the</span><span> number of elements added</span><span> so far</span><span>. Unlike a </span><span class="CodeSnippet" style="font-family:Times, serif">CirQueue</span><span>, a hash can </span><span>map </span><span>many </span><span>element</span><span>s</span><span> to </span><span>one </span><span>bucket. Accordingly, “full-ness” is not </span><span style="font-style:italic">how many </span><span style="font-style:italic">elements</span><span>, but instead the </span><span style="font-style:italic">ratio of elements to available buckets</span><span>. We call this the </span><span style="text-decoration:underline">load factor</span><span>. Finally, </span><span class="CodeSnippet" style="font-family:Times, serif">remove</span><span> is </span><span>just what</span><span> you might expect: it accepts a key, and if that key is present, it removes the key-value from the data structure</span><span>, returning</span><span> the value. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Today we will create these exact methods and add them to our </span><span class="CodeSnippet" style="font-family:Times, serif">HashMap</span><span> class implementation:</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Hash</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> R</span><span style="font-size:0.86em">emove</span><span style="font-size:0.86em"> </span></p><p style="line-height:115%"><span>Create </span><span class="CodeSnippet" style="font-family:Times, serif">HashMap</span><span> method </span><span class="CodeSnippet" style="font-family:Times, serif">remove(key)</span><span> that finds</span><span> key, removes key/value pair, and returns the value (or </span><span class="CodeSnippet" style="font-family:Times, serif">null</span><span> if key not found in our map).</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Hash</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> G</span><span style="font-size:0.86em">row</span><span style="font-size:0.86em"> </span></p><p style="line-height:115%"><span>Write a method </span><span class="CodeSnippet" style="font-family:Times, serif">grow()</span><span> to increase the internal array of buckets by 50% (20-element array would become 30 elements). Afterward, rehash all keys, since your </span><span style="font-weight:bold">mod</span><span> factor has changed.... </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Hash: A</span><span style="font-size:0.86em">dd</span></p><p style="line-height:115%"><span>Create </span><span class="CodeSnippet" style="font-family:Times, serif">addMap(</span><span class="CodeSnippet" style="font-family:Times, serif">HashMap</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> that accepts a</span><span>nother</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">HashMap</span><span> of key-value pairs</span><span> and adds each pair to the existing map. </span><span>For </span><span>duplicate keys, new values overwrite old ones. </span></p><p><span style="font-weight:bold">&#xa0;</span></p><p><span style="font-weight:bold">Second: </span><span>incorporate a boolean input indicating whether new keys should overwrite existing. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Hash: L</span><span style="font-size:0.86em">oad Factor</span></p><p style="line-height:115%"><span>We may eventually </span><span>want to grow our array size. Create </span><span class="CodeSnippet" style="font-family:Times, serif">HashMap</span><span> method </span><span class="CodeSnippet" style="font-family:Times, serif">loadFactor()</span><span> to return </span><span>an elements/</span><span>buckets ratio to monitor this.</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Hash</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> S</span><span style="font-size:0.86em">et Size</span></p><p style="line-height:115%"><span>Write a method </span><span class="CodeSnippet" style="font-family:Times, serif">setSize(newCap)</span><span> to set the capacity of the internal bucket array to a specific length. As with </span><span class="CodeSnippet" style="font-family:Times, serif">grow()</span><span>, after changing the array length, you must rehash all keys.</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Hash: S</span><span style="font-size:0.86em">elect Keys</span></p><p style="line-height:115%"><span>Create method </span><span class="CodeSnippet" style="font-family:Times, serif">selectKeys(keyArray)</span><span> </span><span>to</span><span> accepts an array of keys</span><span>. R</span><span>eject those keys in the existing map that are NOT in that array. </span><span>If your map contains </span><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">cool</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">:</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">Pariece</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">, </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">smart</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">:</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">Pariece</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">, </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">tall</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">:</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">Kareem</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">}</span><span>, then </span><span class="CodeSnippet" style="font-family:Times, serif">map.selectKeys([</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">cool</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">,</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">smart</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">])</span><span> should change </span><span>map</span><span> to </span><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">cool</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">:</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">Pariece</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">, </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">smart</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">:</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">Pariece</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">}</span><span>.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"></div></body></html>