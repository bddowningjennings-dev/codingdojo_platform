<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_94"><span>Set Theory Recap</span></h2><p><span>We explored Set Theory, including Sets vs. Multisets, Ordered vs. Unordered, and set </span><span>operations such as Merge, Union, </span><span>Intersection</span><span> and Subset</span><span>. Along the way we discovered universal principles, such as: </span></p><ul style="list-style-type:disc; margin:0pt; padding-left:0pt"><li class="Normal1" style="font-family:serif; margin-left:28.06pt; padding-left:7.94pt; text-indent:0pt"><span style="font-family:Arial">Ordered sets </span><span style="font-family:Arial">should</span><span style="font-family:Arial"> be managed by iterating them concurrently, matching up values. </span></li><li class="Normal1" style="font-family:serif; margin-left:28.06pt; padding-left:7.94pt; text-indent:0pt"><span style="font-family:Arial">Unordered sets can be managed with associative arrays, where set members become keys, and values are booleans (for an Unordered Set) or counts (for an Unordered Multiset). </span></li></ul><p><span>&#xa0;</span></p><p><span>&#xa0;</span></p><p><span>Looking for a break from Unions and intersections? Here’s something completely different. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">My Very Own Square Root</span></p><p class="Normal1" style="line-height:115%"><span>Write your own square root function. You may not use math functions or operators except for </span><span class="CodeSnippet" style="font-family:Times, serif">*</span><span>, the built-in multiplier. Given an </span><span style="font-style:italic">integer</span><span>, you should return an </span><span style="font-style:italic">integer</span><span>. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">Second: </span><span>accept and return </span><span style="font-style:italic">floating-point numbers</span><span>, accurate to two decimal places. </span></p><p class="Normal1"><span>&#xa0;</span></p><p><span>Next, we </span><span>will </span><span>revisit our old friend the </span><span style="font-style:italic">queue</span><span>, but with a wonderful twist!</span></p><p class="Normal1" style="font-size:1.27em; line-height:115%"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 13</span><span> – Sets and Priority Queues</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>Queues and Stacks are easy to construct, and values can be quickly added and removed. They are </span><span style="font-style:italic">optimized</span><span> for quick addition – and quick removal as well, </span><span style="font-style:italic">if </span><span style="font-style:italic">you want </span><span style="font-style:italic">v</span><span style="font-style:italic">alues </span><span style="font-style:italic; text-decoration:underline">in order they were added</span><span> (or </span><span style="font-style:italic">reverse</span><span> for Stacks). They are </span><span style="font-style:italic; font-weight:bold">not</span><span> optimized for search: elements are stored linearly, per insertion time, without regard for values themselves. We might (for example) iterate all values to find the lowest. </span></p></div></body></html>