<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h1 id="navPoint_59"><img src="item_067.png" width="216" height="65" alt="" style="float:left; margin:0pt 9pt" /><span>Chapter 6</span><span> – Queues and Stacks</span></h1><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="margin-left:36pt"><span style="font-style:italic">Hey! Hold this book for me. Also, could you take this note</span><span style="font-style:italic">-</span><span style="font-style:italic">to</span><span style="font-style:italic">-</span><span style="font-style:italic">self I wrote on a slip of paper? Oh, and I almost forgot – someone important called for you. Here’s the phone number – ready?</span></p><p><span>&#xa0;</span></p><p><span>It’s crazy how much we are asked to commit to, and recall from, memory on a daily basis. That’s why we have machines save this information for us! Devices are better than humans at storing data </span><span style="font-style:italic">primarily</span><span> </span><span>they</span><span> are </span><span style="font-style:italic; text-decoration:underline">faster</span><span> (and not forgetful!) and have an expandable amount of storage space. </span></p><p><span>&#xa0;</span></p><p><span>When we create software systems, we make choices about how </span><span>to</span><span> store and organize information, and these choices significantly impact the performance of our systems. </span><span>It is always wise to borrow great ideas from the past, and over time </span><span>well-known patterns have emerged for storing, managing and retrieving information. These patterns are reflected in reusable code called </span><span style="font-style:italic">data structures</span><span>. </span></p><p><span>&#xa0;</span></p><p><span>Put simply (and obviously), data structures handle </span><span style="font-style:italic">data</span><span> – they </span><span>store, organize, and retrieve information. There are many different data structures; each exists because it is optimized for a certain set of usage scenarios. Said another way, each data structure has its own priorities about what aspects are important. </span><span>As a result, each data structure has strengths and weaknesses that make it a good choice for certain situations and a poor choice for others. </span><span>Everything is a tradeoff after all – if you optimize for everything, then you are really optimizing for nothing. </span></p><p><span>&#xa0;</span></p><p><span>In general, these choices are design tradeoffs that data structure creators make: how the data structure consumes memory, which of its functions it expects to be most frequently called, etc. Understanding these tradeoffs enables you to make intentional decisions about which data structure to use in your particular situation. If you know, for example, that you will constantly search your data structure for random values, but will rarely add or remove values f</span><span>rom it, then instead of a linked list you might choose an array (or perhaps a tree, as we’ll see in a few weeks) for your data structure</span><span>. </span></p><p><span>&#xa0;</span></p><p><span>You have already worked closely with a </span><span>few</span><span> data structures– these include </span><span>arrays, strings (closely related to arrays) and </span><span>singly linked lists. This chapter we will learn about a number of new data structures, including the Stack and various flavors of Queues. We will also dive into how existing data structures change when we </span><span>alter</span><span> how they deal with duplicate values. </span></p><p><span>&#xa0;</span></p><p><span>As we study data structures, it is important to keep in mind that these data structures could be implemented in a number of ways, using different building blocks underneath. For this reason, data structures such as Queues are considered </span><span style="font-style:italic">Abstract Data Types</span><span>. They are considered </span><span style="font-style:italic">abstract</span><span> because the outward behavior of the data structure is well understood, but there is no requirement on how the data structure is constructed internally. We could choose to </span><span>reimplement</span><span> an existing Abstract Data Type</span><span> in an entirely different manner</span><span>, and as long as we maintain the same Abstract interface, </span><span>this </span><span>should </span><span>cause </span><span>no problems</span><span> for all other software that uses that Abstract Data Type</span><span>. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="PageHeader"><br style="page-break-before:always; clear:both" /><span>Chapter 6</span><span> – Queues and Stacks</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>