<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_104"><span>Breadth-First Search</span></h2><p><span>Previously we have talked about traversing a binary search tree. Whether we used pre-order, in-order, or post-order, we traversed from the root of the tree all the way to a leaf node, before </span><span>backtracing</span><span>. This is an example of </span><span style="font-weight:bold">depth-first-search</span><span style="font-weight:bold"> (DFS)</span><span>, in which we (starting at the root) explore as far as possible along each branch before exploring adjacent paths. </span></p><p><span>&#xa0;</span></p><p><span>Can you think of a scenario in which DFS is not the best way to traverse a binary tree? Let’s say we have a generic binary tree (not a BST) with 300 nodes, and each node contains a single upper-case letter. How would we find the ‘P’ that was closest to the root node</span><span>? To </span><span>solve this problem, Depth-First Search would not be a great choice. What if we wanted to find </span><span style="font-style:italic; text-decoration:underline">all</span><span> the instances of the letter ‘P’? In that case, we need to visit every node anyway, so DFS is a reasonable choice. </span></p><p><span>&#xa0;</span></p><p><span>T</span><span>o</span><span> find the closest ‘P’, a better strategy would be, as sage Jerry Seinfeld advised, “go for</span><span> the miracle parking spot, then </span><span>concentric circles.” With </span><span style="font-weight:bold">breadth-first search (BFS)</span><span>, we would first start looking at the root node itself, then proceed to every possible node that is only one step further away, then advance to every node that is one step further, etc. (like concentric circles, but in a tree). </span></p><p><span>&#xa0;</span></p><p><span>Breadth-first, used in conjunction with a Queue data struct</span><span>ure, is a good way to advance </span><span>search evenly away from the starting point. Remember, once we examine a given node, we must then check all other nodes of similar distance from the origin, before we check that given node’s children. The Queue can help us remember a node, from the moment we examine </span><span style="font-style:italic">its parent</span><span> until the time we check </span><span style="font-style:italic">it</span><span>. </span></p><p><span>&#xa0;</span></p><p><span>We will encounter BFS later with graphs; for now breadth-first is an important new way to iterate trees.</span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST</span><span style="font-size:0.86em">: Values</span><span style="font-size:0.86em"> for Layer</span></p><p><span>Jeff has divided his workgroup into a perfectly balanced hierarchy, to the extent that his organizational chart looks just like a binary tree</span><span>! To </span><span>learn how things are going “in the trenches”, he wants to have a meeting with all the line managers, but not include their bosses. Given a BST and a layer number (starting at zero for the root), return an array containing all the values at that layer in the BST. If a BST is a </span><span style="font-style:italic; text-decoration:underline">full</span><span> tree, what percentage of nodes are leaves? What percentage are ‘first-level managers’?</span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: </span><span style="font-size:0.86em">Layer</span><span style="font-size:0.86em"> </span><span style="font-size:0.86em">Arr</span><span style="font-size:0.86em">ay</span><span style="font-size:0.86em">s</span></p><p><span>Given a BST, return a two-dimensional array containing all values in the BST. The outer array represents each layer (starting at zero for the root), and the inner array for each layer represents the values at that layer in the BST. </span></p><p><br style="page-break-before:always; clear:both" /></p></div></body></html>