<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_75"><span>T-Diagrams and Recursion</span></h2></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Normal1"><span>Re</span><span>cursion is a powerful technique</span><span> but </span><span>may</span><span> be difficult to understand </span><span>initially. Tracing </span><span>recursive function</span><span>s</span><span> can be confusing unless we remember</span><span> that </span><span style="text-decoration:underline">each</span><span style="text-decoration:underline"> successive recursive call is a </span><span style="text-decoration:underline">different context</span><span>, with a completely new T-Diagram. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span>Let’s trace </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma</span><span class="CodeSnippet" style="font-family:Times, serif">()</span><span> when given </span><span class="CodeSnippet" style="font-family:Times, serif">2.718</span><span>:</span><span> </span></p><p class="Normal1" style="line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span class="CodeSnippet" style="font-family:Times, serif">function rSigma(num)</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p class="Normal1" style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var returnVal = 0;</span></p><p class="Normal1" style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &gt;= 1) {</span></p><p class="Normal1" style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var intNum = Math.trunc(num);</span></p><p class="Normal1" style="line-height:115%; margin-left:18pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var prevVal = rSigma(intNum–</span><span class="CodeSnippet" style="font-family:Times, serif">1);</span></p><p class="Normal1" style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">returnVal = prevVal + intNum;</span></p><p class="Normal1" style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p class="Normal1" style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return returnVal;</span></p><p class="Normal1" style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Normal1" style="line-height:115%"><img src="item_173.png" width="149" height="107" alt="" style="float:left; margin:0pt 9pt" /><span>Upon entering, we set </span><span class="CodeSnippet" style="font-family:Times, serif">returnVal</span><span>, enter an </span><span class="CodeSnippet" style="font-family:Times, serif">IF</span><span>, set </span><span class="CodeSnippet" style="font-family:Times, serif">intNum</span><span> and call </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma</span><span>. </span><span>At this point, the eventual value of </span><span class="CodeSnippet" style="font-family:Times, serif">prevVal</span><span> is unknown. All we know is that it will be set to the return value from </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma(1)</span><span>, which has </span><span>not yet returned. </span><span>Once</span><span> it does, we can cont</span><span>inue onward in this </span><span>diagram. </span><span>Let’s now</span><span> work through </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma(1)</span><span>. </span><span>This new function call </span><span>will</span><span> have</span><span> a new T-diagram.</span></p><p class="Normal1"><img src="item_035.png" width="148" height="107" alt="" style="float:left; margin:0pt 9pt" /></p><p class="Normal1" style="line-height:115%"><img src="item_173.png" width="149" height="107" alt="" style="float:left; margin:0pt 9pt" /><span>As</span><span> above, </span><span>upon </span><span>entering </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma(1)</span><span> we set </span><span class="CodeSnippet" style="font-family:Times, serif">returnVal</span><span>, test </span><span class="CodeSnippet" style="font-family:Times, serif">num</span><span>, </span><span>enter </span><span class="CodeSnippet" style="font-family:Times, serif">IF</span><span>, set </span><span class="CodeSnippet" style="font-family:Times, serif">intNum</span><span> and call </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma</span><span class="CodeSnippet" style="font-family:Times, serif">(0)</span><span>. </span><span>Note the </span><span>T-</span><span>d</span><span>iagram</span><span>s</span><span>:</span></p><p class="Normal1"><img src="item_009.png" width="148" height="107" alt="" style="float:left; margin:0pt 9pt" /></p><p class="Normal1" style="line-height:115%"><img src="item_173.png" width="149" height="107" alt="" style="float:left; margin:0pt 9pt" /><span>We are </span><span>now </span><span>two levels deep into </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma</span><span>, but this should not cause concern. The only effect those calls have on </span><span>our</span><span> new </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma</span><span> call is the </span><span>input</span><span>: </span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span>. Unlike previous calls, this </span><span>one </span><span>(</span><span>as</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">num</span><span> is </span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span>) </span><span>does </span><span>not enter the </span><span class="CodeSnippet" style="font-family:Times, serif">IF</span><span>; </span><span>instead return</span><span>ing</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span>, here</span><span>:</span></p><p class="Normal1"><img src="item_080.png" width="127" height="68" alt="" style="float:left; margin:0pt 9pt" /></p><p class="Normal1" style="line-height:115%"><span>On</span><span> exiting </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma(0)</span><span>, that T-diagram is destroyed</span><span>;</span><span> we </span><span>return to previous </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma(1)</span><span> context</span><span>. </span><span>We update </span><span class="CodeSnippet" style="font-family:Times, serif">prevVal</span><span> to </span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span> (</span><span>return value </span><span>from </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma(0)</span><span>)</span><span> </span><span>and </span><span>continue immediately </span><span>after </span><span>the </span><span>previous recursive call</span><span>, setting</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">returnVal</span><span> to </span><span class="CodeSnippet" style="font-family:Times, serif">prevVal+intNum</span><span>, which in our diagram is </span><span class="CodeSnippet" style="font-family:Times, serif">0+1</span><span>. </span><span>Immediately before</span><span> we </span><span>return from </span><span class="CodeSnippet" style="font-family:Times, serif">rSigma(1)</span><span>,</span><span> </span><span>here are </span><span>our diagrams:</span></p><p class="Normal1"><img src="item_173.png" width="149" height="107" alt="" style="float:left; margin:0pt 9pt" /></p><p class="Normal1" style="line-height:115%"><img src="item_148.png" width="138" height="112" alt="" style="float:left; margin:0pt 9pt" /><span>Back at last in our original context, we now know the value of </span><span class="CodeSnippet" style="font-family:Times, serif">prevVal</span><span>: </span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span>. Substituting this into our diagram and continuing from immediately after the recursive call, we set </span><span class="CodeSnippet" style="font-family:Times, serif">returnVal</span><span> to 1+2, and return</span><span> final value </span><span class="CodeSnippet" style="font-family:Times, serif; text-decoration:underline">3</span><span>, shown here:</span><span> </span></p><p class="Normal1"><img src="item_153.png" width="126" height="102" alt="" style="float:left; margin:0pt 9pt" /></p><p class="Normal1"><span>Hopefully this sheds some light on how</span><span> </span><span>recursive code works!</span><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 9 – Recursion </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Recursive Fibonacci</span></p><p style="line-height:115%"><span>Write </span><span class="CodeSnippet" style="font-family:Times, serif">rFib(num)</span><span>. Recursively compute and return</span><span> </span><span style="text-decoration:underline">num</span><span>th</span><span> </span><span>Fibonacci value</span><span>. As earlier, </span><span>treat</span><span> first </span><span>two </span><span>(n</span><span>um</span><span> = 0, n</span><span>um</span><span> = 1) Fibonacci </span><span>vals</span><span> </span><span>as</span><span> 0 and 1.</span><span> Examples:</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">rFib(2)</span><span> = </span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span> (</span><span>0+1</span><span>)</span><span>; </span><span class="CodeSnippet" style="font-family:Times, serif">rFib(3)</span><span> = </span><span class="CodeSnippet" style="font-family:Times, serif">2</span><span> (</span><span>1+1</span><span>)</span><span>; </span><span class="CodeSnippet" style="font-family:Times, serif">rFib(4)</span><span> = </span><span class="CodeSnippet" style="font-family:Times, serif">3</span><span> (</span><span>1+2</span><span>)</span><span>; </span><span class="CodeSnippet" style="font-family:Times, serif">rFib(5)</span><span> = </span><span class="CodeSnippet" style="font-family:Times, serif">5</span><span> (</span><span>2+3</span><span>)</span><span>.</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">rFib(3.65)</span><span> = </span><span class="CodeSnippet" style="font-family:Times, serif">rFib(3)</span><span> </span><span>= </span><span class="CodeSnippet" style="font-family:Times, serif">2</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">rFib(-2)</span><span> = </span><span class="CodeSnippet" style="font-family:Times, serif">rFib(0)</span><span> = </span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span>.</span><span> </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Recursive “Tribonacci”</span></p><p style="line-height:115%"><span>Write function </span><span class="CodeSnippet" style="font-family:Times, serif">rTrib(num)</span><span> to mimic Fibonacci, </span><span>adding</span><span> previous </span><span style="font-style:italic">three</span><span> values instead of </span><span style="font-style:italic">two</span><span>. </span><span>F</span><span>irst three Tribonacci numbers </span><span>are</span><span> 0, 0, 1</span><span>, so</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">rTrib(3)</span><span> = 1 (0+0+1); </span><span class="CodeSnippet" style="font-family:Times, serif">rTrib(4)</span><span> = 2 (0+1+1); </span><span class="CodeSnippet" style="font-family:Times, serif">rTrib(5)</span><span> = 4 (1+1+2); </span><span class="CodeSnippet" style="font-family:Times, serif">rTrib(6)</span><span> = 7 (1+2+4). Handle negatives and non-integers a</span><span>ppropriately and inexpensively.</span><span> </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Paging Dr. Ackermann</span></p><p style="line-height:115%"><span>The Ackermann function is among the earliest examples of a computable but not primitive-recursive function. It grows rapidly, and hence </span><span>can overflow</span><span> the JavaScript stack frame even at very low values. Th</span><span>is function accepts two non-negative integer values, </span><span class="CodeSnippet" style="font-family:Times, serif">num1</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">num2</span><span>, and follows these rules:</span></p><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; text-indent:-18pt"><span style="font-size:0.91em">1)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">ackermann(</span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span class="CodeSnippet" style="font-family:Times, serif">,num2) == num2+1</span><span>;</span></p><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em">2)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">ackermann(num1,0) == ackermann(num1-1,1)</span><span> if num1 &gt; 0 (otherwise see #1);</span></p><p class="ListParagraph" style="line-height:115%; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em">3)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">ackermann(num1,num2) == ackermann(num1-1,ackermann(num1,num2-1))</span><span>.</span></p><p style="line-height:115%"><span>Don’t be dismayed if a </span><span class="CodeSnippet" style="font-family:Times, serif">num1</span><span> value as low as 4 “blows your stack”. That’s the nature of this function! </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Zibonacci</span></p><p><span>This function borrows </span><span>ideas from the Fibonacci series, but the calculated results appear to zig and zag, hence the name. A </span><span>so-called ‘</span><span>Zibonacci</span><span>’</span><span> </span><span>seri</span><span>es would be defined by the following rules:</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; text-indent:-18pt"><span style="font-size:0.91em">1)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">Zib(0) == 1</span><span>; </span></p><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em">2)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">Zib(1) == 1</span><span>; </span></p><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em">3)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">Zib(2) == 2</span><span>;</span><span> </span></p><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em">4)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">Zib(</span><span class="CodeSnippet" style="font-family:Times, serif">2n+1) == Zib(n)+Zib(n-1)+</span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span>, if n &gt; 0 (</span><span>i.e.</span><span> </span><span>odd values 3 and higher);</span></p><p class="ListParagraph" style="line-height:115%; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em">5)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">Zib(2n)</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">== Zib(n)+Zib(n+1)+</span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span>, if n &gt; 1 (</span><span>i.e.</span><span> </span><span>even values 4 and higher).</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Create the</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">Zibonacci(num)</span><span> function. What is </span><span class="CodeSnippet" style="font-family:Times, serif">Zibonacci(1</span><span class="CodeSnippet" style="font-family:Times, serif">0)</span><span>?</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">Zibonacci(1</span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span>?</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span style="font-weight:bold">Second:</span><span> For a given number that </span><span style="font-style:italic">might</span><span> be a Zibonacci result, find the </span><span style="text-decoration:underline">largest</span><span> </span><span>index that maps to that result. </span><span class="CodeSnippet" style="font-family:Times, serif">bestZibNum(3186) == 2467</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">bestZibNum(3183) == null</span><span>. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><span>&#xa0;</span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 9 – Recursion </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>