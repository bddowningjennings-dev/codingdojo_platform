<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_87"><span>Stability</span></h2><p class="Normal1"><span>In most of our sorting work so far, we have dealt with simple collections of single values, such as an array of 15 numbers</span><span>. </span><span>In real life, however, data is rarely that minimal, and never that simple</span><span>. </span><span>Much more likely would be a linked list or array containing many thousand records, and each record contains 5-10 different fields</span><span>. To </span><span>sort these records, we may need to reference multiple fields (for example: sorting customer events by last name, then first name, then event date)</span><span>. </span><span>One strategy, when sorting by multiple fields, is to sort first by the least important factor (date), then by more important factors (first name), ending with the most important (last name)</span><span>. </span></p><p class="Normal1"><br /><span>However, this multi</span><span>-</span><span>pass strategy </span><span style="font-style:italic">only</span><span> works if our sorting algorithm is able to retain the existing order, when finding duplicate values during subsequent passes</span><span>. Some algorithms, such as s</span><span>election</span><span> s</span><span>ort and </span><span>q</span><span>uick</span><span> s</span><span>ort, swap elements across significant parts of the input array, and hence do not guarantee to keep duplicate values in their original sequence; they </span><span style="font-style:italic">destabilize </span><span>any preexisting ordering</span><span>. </span><span>If we have already sorted </span><span>“Buster</span><span> Jones</span><span>”</span><span> ahead of </span><span>“</span><span>David Jones</span><span>”</span><span> based on first name, we don</span><span>’</span><span>t later want to carelessly put David Jones ahead of </span><span>Buster</span><span> Jones just because their last names are identical</span><span>. With selection and q</span><span>uick</span><span> sorts</span><span>, this </span><span>unfortunately </span><span>migh</span><span>t happen! </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>On the other hand, insertion sort and b</span><span>ubble</span><span> </span><span>sort only swap adjacent elements, so existing sequence is preserved when they encounter duplicate values</span><span>. Insertion sort and bubble s</span><span>ort are </span><span style="text-decoration:underline">Stable</span><span> sorting algorithms</span><span>; they hold any previous order </span><span style="font-style:italic">stable</span><span> when doing their work. </span><span>Again, this becomes a factor mainly when doing successive sorting passes, such as sorting by multiple fields (e.g. userID, date).</span><span> However, stability doesn’t mean looking at additional fields to </span><span style="font-style:italic">break ties</span><span>; it means that in case of a tie, the </span><span style="font-style:italic">value that was previously first</span><span style="font-style:italic">,</span><span style="font-style:italic"> stays first</span><span>.</span><span> </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Array: </span><span style="font-size:0.86em">Quick Sort</span></p><p class="Normal1" style="line-height:115%"><span>Create a function that</span><span> </span><span>uses yesterday</span><span>’</span><span>s </span><span class="CodeSnippet" style="font-family:Times, serif">p</span><span class="CodeSnippet" style="font-family:Times, serif">artitionArray</span><span class="CodeSnippet" style="font-family:Times, serif">()</span><span> to sort </span><span>an</span><span> array in-place. With yesterday</span><span>’</span><span>s code plus </span><span>a </span><span>very few new lines, you</span><span> will implement</span><span> QuickSort! What are the run-time and space complexities of </span><span>your </span><span class="CodeSnippet" style="font-family:Times, serif">q</span><span class="CodeSnippet" style="font-family:Times, serif">uickSortArr</span><span> implementation?</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Array: </span><span style="font-size:0.86em">Merge Sort</span></p><p style="line-height:115%"><span>Use </span><span>the </span><span class="CodeSnippet" style="font-family:Times, serif">combineArrs()</span><span> function above to construct </span><span class="CodeSnippet" style="font-family:Times, serif">mergeSortArr()</span><span> for an unsorted array. What </span><span>are</span><span> the run-time </span><span>and space complexities</span><span> of </span><span>your </span><span class="CodeSnippet" style="font-family:Times, serif">m</span><span class="CodeSnippet" style="font-family:Times, serif">ergeSortArr</span><span> solution</span><span>?</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Array: </span><span style="font-size:0.86em">Partition3</span></p><p class="Normal1" style="line-height:115%"><span>P</span><span>revious </span><span class="CodeSnippet" style="font-family:Times, serif">p</span><span class="CodeSnippet" style="font-family:Times, serif">artition</span><span class="CodeSnippet" style="font-family:Times, serif">()</span><span> implementation</span><span>s do not group</span><span> </span><span>duplicates of the </span><span>pivot together</span><span>. Create </span><span class="CodeSnippet" style="font-family:Times, serif">partition3()</span><span> </span><span>to keep </span><span>pivot elements together; return a</span><span>n</span><span> array containing </span><span>indices for </span><span style="font-style:italic">first pivot</span><span> and </span><span style="font-style:italic">first greater</span><span>. </span><span>Change</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">[5,1,8,4,9,2,5,3]</span><span> to </span><span class="CodeSnippet" style="font-family:Times, serif">[1,4,2,3,5,5,8,9]</span><span> and return </span><span class="CodeSnippet" style="font-family:Times, serif">[4,6]</span><span>. Note: other 5 moved next to pivot. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">Second</span><span style="font-weight:bold">:</span><span> p</span><span>ick a more optimal pivot. </span></p><p class="Normal1"><span style="font-weight:bold">Third</span><span style="font-weight:bold">:</span><span> </span><span>p</span><span>artition only a </span><span style="font-style:italic">portion</span><span>, with </span><span style="font-style:italic">start</span><span> and </span><span style="font-style:italic">end</span><span>.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 12</span><span> – Sorts </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p class="Normal1"><span>As </span><span>mentioned before, when </span><span>analyzing software</span><span> performance</span><span>, we look </span><span>at runtime performance (</span><span>duration to</span><span> run to completion), but also </span><span>its consumption of</span><span> other resources</span><span>. Will</span><span> it require a huge amount of disk storage?</span><span> </span><span>Is it excessively chatty</span><span> on our</span><span> network?</span><span> Does</span><span> i</span><span>t mercilessly drain our battery</span><span> in mere minutes?</span><span> An</span><span> important</span><span> factor, </span><span>and sometimes easiest to quantify</span><span>,</span><span> is extra </span><span style="font-style:italic">memory</span><span> (in addition to input) it </span><span>requires. </span><span>RAM consumption could be </span><span style="font-style:italic">heap</span><span> (e.g. allocate space to copy our </span><span>array</span><span>!), or </span><span style="font-style:italic">call stack </span><span>(recursively call ourselves, once for every </span><span>node</span><span>!)</span><span>. </span><span>Ei</span><span>ther way</span><span> we might run</span><span> out of memory, at which point </span><span>depending on where </span><span>our code runs, it will </span><span>slow to a crawl (best-case) or crash (worst-case, common)</span><span>. </span></p></div></body></html>