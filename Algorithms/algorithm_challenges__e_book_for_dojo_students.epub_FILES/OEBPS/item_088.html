<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_76"><span>Dynamic Programming and Memoization</span></h2><p><span>(No, it’s not </span><span>a typo – it really is ‘memoization’, not ‘memo</span><span style="text-decoration:underline">r</span><span>ization’.)</span><span> </span></p><p><span>&#xa0;</span></p><p><span>Recursion is a powerful technique that allows us to explore multiple pathways. In general, we break a problem into smaller problems</span><span>;</span><span> often we simply feed those smaller proble</span><span>ms in to the same function</span><span> to eventually get </span><span>a</span><span> solution. Sometimes</span><span>,</span><span> it isn’t that clean – sometimes we need to save some partial progress</span><span> to</span><span> build upon in subsequent recursive calls. </span><span>This is when </span><span>a ‘</span><span style="font-style:italic; font-weight:bold">memo</span><span>’ is valuable. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>A memo is any of </span><span>‘note to self’ that you send along with </span><span>a</span><span> recursive call, so that it can take advantage of previous progress you have made. You might be able to incorporate this into a single-function recursive solution, by adding an additional parameter that </span><span>is</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">undefined</span><span> when your function is called externally. In subsequent recursive calls </span><span>you make to yourself</span><span>, you </span><span>could</span><span> include a </span><span style="font-style:italic">memo</span><span> here that might be a fragment of a solution that you are trying to complete, or an array to which you are pushing all possible solutions – or perhaps both, using two parameters that are not in the original function call. </span><span>Other times, your original function is an entry point, calling </span><span>a</span><span> recursive function using additional parameters</span><span>, like this:</span><span> </span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">//</span><span class="CodeSnippet" style="font-family:Times, serif">///</span><span class="CodeSnippet" style="font-family:Times, serif"> Simple function </span><span class="CodeSnippet" style="font-family:Times, serif">to kick</span><span class="CodeSnippet" style="font-family:Times, serif"> off </span><span class="CodeSnippet" style="font-family:Times, serif">the</span><span class="CodeSnippet" style="font-family:Times, serif"> recursive </span><span class="CodeSnippet" style="font-family:Times, serif">version, with</span><span class="CodeSnippet" style="font-family:Times, serif"> default</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">//</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">values for </span><span class="CodeSnippet" style="font-family:Times, serif">the </span><span class="CodeSnippet" style="font-family:Times, serif">number of opens pending (0)</span><span class="CodeSnippet" style="font-family:Times, serif">, </span><span class="CodeSnippet" style="font-family:Times, serif">the </span><span class="CodeSnippet" style="font-family:Times, serif">substring</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">fragment</span><span class="CodeSnippet" style="font-family:Times, serif"> </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// we</span><span class="CodeSnippet" style="font-family:Times, serif">'</span><span class="CodeSnippet" style="font-family:Times, serif">ve built so far </span><span class="CodeSnippet" style="font-family:Times, serif">(</span><span class="CodeSnippet" style="font-family:Times, serif">""</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span class="CodeSnippet" style="font-family:Times, serif">,</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">and </span><span class="CodeSnippet" style="font-family:Times, serif">the </span><span class="CodeSnippet" style="font-family:Times, serif">array of </span><span class="CodeSnippet" style="font-family:Times, serif">complete </span><span class="CodeSnippet" style="font-family:Times, serif">solutions ([])</span><span class="CodeSnippet" style="font-family:Times, serif">. </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function allValidNParens(numParens)</span><span class="CodeSnippet" style="font-family:Times, serif"> {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var </span><span class="CodeSnippet" style="font-family:Times, serif">solutions</span><span class="CodeSnippet" style="font-family:Times, serif"> = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">rValidNParens</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.91em">(</span><span class="CodeSnippet" style="font-family:Times, serif">numParens</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.91em">,</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.91em"> </span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.91em">,</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.91em"> </span><span class="CodeSnippet" style="font-family:Times, serif">""</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.91em">,</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.91em"> </span><span class="CodeSnippet" style="font-family:Times, serif">solutions</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.91em">);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return </span><span class="CodeSnippet" style="font-family:Times, serif">solutions</span><span class="CodeSnippet" style="font-family:Times, serif">;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span class="CodeSnippet">&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">//</span><span class="CodeSnippet" style="font-family:Times, serif">/// Recursive A</span><span class="CodeSnippet" style="font-family:Times, serif">ll</span><span class="CodeSnippet" style="font-family:Times, serif">-</span><span class="CodeSnippet" style="font-family:Times, serif">Valid</span><span class="CodeSnippet" style="font-family:Times, serif">-</span><span class="CodeSnippet" style="font-family:Times, serif">Combinations</span><span class="CodeSnippet" style="font-family:Times, serif">-</span><span class="CodeSnippet" style="font-family:Times, serif">Of</span><span class="CodeSnippet" style="font-family:Times, serif">-</span><span class="CodeSnippet" style="font-family:Times, serif">N</span><span class="CodeSnippet" style="font-family:Times, serif">-Pairs-</span><span class="CodeSnippet" style="font-family:Times, serif">Parentheses func</span><span class="CodeSnippet" style="font-family:Times, serif">.</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Parameters: num</span><span class="CodeSnippet" style="font-family:Times, serif">ber of</span><span class="CodeSnippet" style="font-family:Times, serif"> parens remaining, num</span><span class="CodeSnippet" style="font-family:Times, serif">ber of</span><span class="CodeSnippet" style="font-family:Times, serif"> opens pending,</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">//</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">unfinished </span><span class="CodeSnippet" style="font-family:Times, serif">substring </span><span class="CodeSnippet" style="font-family:Times, serif">fragment we</span><span class="CodeSnippet" style="font-family:Times, serif">'</span><span class="CodeSnippet" style="font-family:Times, serif">re building, </span><span class="CodeSnippet" style="font-family:Times, serif">array of solutions</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function rValidNParens(parens,</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">opens,</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">subStr,</span><span class="CodeSnippet" style="font-family:Times, serif"> solutions</span><span class="CodeSnippet" style="font-family:Times, serif">) </span><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">// If no parens/opens remain, this fragment is a valid solution.</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (!parens &amp;&amp; !opens) { </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">solutions</span><span class="CodeSnippet" style="font-family:Times, serif">.push(subStr);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">// If opens remain, one option is to close one.</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (opens) </span><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">rValidNParens(parens, opens-</span><span class="CodeSnippet" style="font-family:Times, serif">1,</span><span class="CodeSnippet" style="font-family:Times, serif"> subStr</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">+</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">")", </span><span class="CodeSnippet" style="font-family:Times, serif">solutions</span><span class="CodeSnippet" style="font-family:Times, serif">);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">// If </span><span class="CodeSnippet" style="font-family:Times, serif">unused </span><span class="CodeSnippet" style="font-family:Times, serif">parens remain, one option is to open a new one.</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (parens) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">rValidNParens(parens-1, opens+</span><span class="CodeSnippet" style="font-family:Times, serif">1,</span><span class="CodeSnippet" style="font-family:Times, serif"> subStr</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">+</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">"(", </span><span class="CodeSnippet" style="font-family:Times, serif">solutions</span><span class="CodeSnippet" style="font-family:Times, serif">);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">// solutions </span><span class="CodeSnippet" style="font-family:Times, serif">array </span><span class="CodeSnippet" style="font-family:Times, serif">is a </span><span class="CodeSnippet" style="font-family:Times, serif">'</span><span class="CodeSnippet" style="font-family:Times, serif">live</span><span class="CodeSnippet" style="font-family:Times, serif">'</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">obj</span><span class="CodeSnippet" style="font-family:Times, serif">; </span><span class="CodeSnippet" style="font-family:Times, serif">we don</span><span class="CodeSnippet" style="font-family:Times, serif">'</span><span class="CodeSnippet" style="font-family:Times, serif">t need to return it.</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 9</span><span> – Recursion </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p class="Normal1"><span>This </span><span>chapter</span><span> you will familiarize yourself with recursion. Some or all of the following important concepts will be used in this </span><span>chapter’</span><span>s challenges.</span></p><p class="Normal1" style="line-height:normal"><span>&#xa0;</span></p><p class="Normal1"><span style="font-style:italic">B</span><span style="font-style:italic">ase C</span><span style="font-style:italic">ases</span><span style="font-style:italic">F</span><span style="font-style:italic">orward </span><span style="font-style:italic">Progress</span><span style="font-style:italic">C</span><span style="font-style:italic">all S</span><span style="font-style:italic">tack</span><span style="font-style:italic">Memoization</span><span style="font-style:italic">D</span><span style="font-style:italic">ynamic P</span><span style="font-style:italic">rogramming</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Recursive Binary Search</span></p><p class="Normal1" style="line-height:115%"><span>Given a sorted array and a </span><span>value, </span><span>recursively determine</span><span> whether value is found within array. </span><span class="CodeSnippet" style="font-family:Times, serif">rBinarySearch([1,3,5,6],4)</span><span> = </span><span class="CodeSnippet" style="font-family:Times, serif">false</span><span>; </span><span class="CodeSnippet" style="font-family:Times, serif">rBinarySearch([4,5,6,8,12],5)</span><span> = </span><span class="CodeSnippet" style="font-family:Times, serif">true</span><span>. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Greatest Common Factor</span></p><p style="line-height:115%"><span>Given two integers, create </span><span class="CodeSnippet" style="font-family:Times, serif">rGCF(num1,</span><span class="CodeSnippet" style="font-family:Times, serif">num2)</span><span> to recursively determine Greatest Common Factor (the largest integer dividing evenly into both). Greek mathematician Euclid demonstrated these facts: </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; text-indent:-18pt"><span style="font-size:0.91em">1)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">gcf(a,b) == a</span><span>, if a == b;</span></p><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em">2)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">gcf(a,b) == gcf(a-b,b)</span><span>, if a&gt;b;</span></p><p class="ListParagraph" style="line-height:115%; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em">3)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span class="CodeSnippet" style="font-family:Times, serif">gcf(a,b) == gcf(a,b-a)</span><span>, if b&gt;a. </span></p><p style="line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-weight:bold">Second:</span><span> rework facts #2 and #3 to reduce stack consumption and expand </span><span class="CodeSnippet" style="font-family:Times, serif">rGCF</span><span>’s reach. You should be able to compute </span><span class="CodeSnippet" style="font-family:Times, serif">rGCF(1</span><span class="CodeSnippet" style="font-family:Times, serif">23456,987654)</span><span>. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Tarai</span></p><p style="line-height:115%"><span>The </span><span class="CodeSnippet" style="font-family:Times, serif">tarai</span><span> (</span><span>Japanese: </span><span>“to pass around”) </span><span>function </span><span>was created to profile recursive performance </span><span>in</span><span> various systems and languages. Unlike other functions, numbers don't get particularly large, but the amount of recursion is significant.</span><span> The tarai function accepts three parameters, and is defined as:</span></p><p style="line-height:115%; margin-left:36pt"><span>1) </span><span class="CodeSnippet" style="font-family:Times, serif">tarai(x,y,z</span><span class="CodeSnippet" style="font-family:Times, serif">) =</span><span class="CodeSnippet" style="font-family:Times, serif">= y</span><span>, if x &lt;= y</span><span> (otherwise see rule #2); </span></p><p style="line-height:115%; margin-left:36pt"><span>2) </span><span class="CodeSnippet" style="font-family:Times, serif">tarai(</span><span class="CodeSnippet" style="font-family:Times, serif">x,y</span><span class="CodeSnippet" style="font-family:Times, serif">,</span><span class="CodeSnippet" style="font-family:Times, serif">z</span><span class="CodeSnippet" style="font-family:Times, serif">) == tarai(tarai(</span><span class="CodeSnippet" style="font-family:Times, serif">x-1,y,z</span><span class="CodeSnippet" style="font-family:Times, serif">),tarai(</span><span class="CodeSnippet" style="font-family:Times, serif">y-1,z,x</span><span class="CodeSnippet" style="font-family:Times, serif">),tarai(</span><span class="CodeSnippet" style="font-family:Times, serif">z-1,x,y</span><span class="CodeSnippet" style="font-family:Times, serif">))</span><span>. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Calling </span><span class="CodeSnippet" style="font-family:Times, serif">tarai(10,2,9)</span><span> should return </span><span class="CodeSnippet" style="font-family:Times, serif">9</span><span> (after recursing 4145 times!). </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">String</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> In-Order Subsets</span></p><p style="line-height:115%"><span>Create </span><span class="CodeSnippet" style="font-family:Times, serif">strSubsets(str)</span><span>. Return an array with every possible </span><span style="font-style:italic">in-order character subset</span><span> of str. The resultant array itself need not be in any specific order – it is the subset of letters in each string that must be in the same order as they were in the original string. Given </span><span class="CodeSnippet" style="font-family:Times, serif">"abc"</span><span>, return an array that includes </span><span class="CodeSnippet" style="font-family:Times, serif">["", "c", "b", "bc", "a", "ac", "ab", "abc"]</span><span> (in any order).</span></p><p><span>&#xa0;</span></p><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 9 – Recursion </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>This </span><span>chapter</span><span> you will familiarize yourself with recursion. Some or all of the following important concepts will be used in this </span><span>chapter’</span><span>s challenges.</span></p><p class="Normal1" style="line-height:normal"><span>&#xa0;</span></p><p class="Normal1"><span style="font-style:italic">Base C</span><span style="font-style:italic">ases</span><span style="font-style:italic">F</span><span style="font-style:italic">orward </span><span style="font-style:italic">P</span><span style="font-style:italic">rogress</span><span style="font-style:italic">Call S</span><span style="font-style:italic">tack</span><span style="font-style:italic">Memoization</span><span style="font-style:italic">Dynamic P</span><span style="font-style:italic">rogramming</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Recursive List Length</span></p><p><span>Given first node of a singly linked list, create a recursive function that returns number of nodes in that list. </span><span>A</span><span>ssume list contains no loops</span><span> and is short enough that you will not ‘blow your stack’</span><span>.</span><span> </span></p><p style="font-size:1.27em; line-height:115%"><span style="font-family:Wingdings, serif">&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Got Any Grapes?!?</span></p><p class="Normal1"><span>Martin loves grapes. He sees a number of baggies containing grapes, all in a row. Stephen tells him that he can take as many of the baggies as he wants, as long as he doesn’t take two that are next to each other. Martin wants to maximize his number of grapes. Grapes are pretty healthy, so let’s help him out. Create a function to accept an array of non-negative integers representing number of grapes in each adjacent baggy. Your function should return the maximum </span><span>number</span><span> of grapes he can obtain. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Collatz-apalooza</span></p><p style="line-height:115%"><span>Define a function that, given positive integer </span><span class="CodeSnippet" style="font-family:Times, serif">num</span><span>, returns </span><span class="CodeSnippet" style="font-family:Times, serif">num/2</span><span> if </span><span class="CodeSnippet" style="font-family:Times, serif">num</span><span> is even or </span><span class="CodeSnippet" style="font-family:Times, serif">3*num + 1</span><span> if </span><span class="CodeSnippet" style="font-family:Times, serif">num</span><span> is odd. Continuously feeding result back into function results in numerical series such as </span><span class="CodeSnippet" style="font-family:Times, serif">5,16,8,4,2,</span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span>. According to Dr. Lothar Collatz, the series always reaches 1 (and then repeats </span><span class="CodeSnippet" style="font-family:Times, serif">4,2,1,</span><span class="CodeSnippet" style="font-family:Times, serif">4,2,1,</span><span class="CodeSnippet" style="font-family:Times, serif">…</span><span>). </span><span>What starting number requires the most iterations before reaching 1 the first time? </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Telephone Words</span></p><p class="Normal1" style="line-height:115%"><span>Nikki has a new phone number (304-5083) and wants to create a clever way for everyone to remember it. On older telephones, the keypad associates letters with each numeral. Given a seven-digit telephone number, return an array of all possible strings that equate to that phone number. For reference, here is the mapping: </span><span class="CodeSnippet" style="font-family:Times, serif">[2:ABC; 3:DEF; 4:GHI; 5:JKL; 6:MNO; 7:PQRS; 8:TUV; 9:WXYZ]</span><span> – for completeness, map 1 to </span><span class="CodeSnippet" style="font-family:Times, serif">I</span><span> and zero to </span><span class="CodeSnippet" style="font-family:Times, serif">O</span><span>. For example, given a phone number 818-2612, return an array of 243 different strings, including “vitamic” and “titania”. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 9 – Recursion </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Rising Squares</span></p><p style="line-height:115%"><span>Ever since her dad discovered universal truths about triangles, Sophia Pythagoras has loved square numbers. Given positive integer, successively print squares of integers up to that integer, first ascending odds, then descending evens. Solve recursively with no loops. Ex.: </span><span class="CodeSnippet" style="font-family:Times, serif">risingSquare(5)</span><span> returns </span><span class="CodeSnippet" style="font-family:Times, serif">"1, 9, 25, 16, 4"</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">risingSquare(8)</span><span> returns </span><span class="CodeSnippet" style="font-family:Times, serif">"1, 9, 25, 49, 64, 36, 16, 4"</span><span>. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Binary String Expansion</span></p><p class="Normal1" style="line-height:115%"><span>You </span><span>are</span><span> given a</span><span> string containing chars</span><span> </span><span>‘</span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span>’, ‘</span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span>’</span><span>, and </span><span>‘</span><span class="CodeSnippet" style="font-family:Times, serif">?</span><span>’</span><span>. For every </span><span>‘</span><span class="CodeSnippet" style="font-family:Times, serif">?</span><span>’, either ‘</span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span>’</span><span> or </span><span>‘</span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span>’</span><span> </span><span>can be substituted</span><span>. Write a recursive function </span><span>to return</span><span> array of </span><span style="font-style:italic">all</span><span> valid strings </span><span>with ‘</span><span class="CodeSnippet" style="font-family:Times, serif">?</span><span>’ chars expanded to ‘</span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span>’ or ‘</span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span>’. </span><span class="CodeSnippet" style="font-family:Times, serif">binStrExpand("1?0?") =&gt;</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">["1000","1001","1100","1101"]</span><span>. If you</span><span> use string functions such as </span><span class="CodeSnippet" style="font-family:Times, serif">slice()</span><span>, use them sparingly</span><span>, as they are expensive.</span><span> </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">String Anagrams</span></p><p class="Normal1" style="line-height:115%"><span>Given a string, return array where each element is a string representing a different anagram (a different sequence of the letters in that string)</span><span>. </span><span>Example: if given </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">lim</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span>, return </span><span class="CodeSnippet" style="font-family:Times, serif">["</span><span class="CodeSnippet" style="font-family:Times, serif">ilm</span><span class="CodeSnippet" style="font-family:Times, serif">", "</span><span class="CodeSnippet" style="font-family:Times, serif">iml</span><span class="CodeSnippet" style="font-family:Times, serif">", "</span><span class="CodeSnippet" style="font-family:Times, serif">lim</span><span class="CodeSnippet" style="font-family:Times, serif">", "</span><span class="CodeSnippet" style="font-family:Times, serif">lmi</span><span class="CodeSnippet" style="font-family:Times, serif">", "</span><span class="CodeSnippet" style="font-family:Times, serif">mil</span><span class="CodeSnippet" style="font-family:Times, serif">", "</span><span class="CodeSnippet" style="font-family:Times, serif">mli</span><span class="CodeSnippet" style="font-family:Times, serif">"]</span><span>. For this challenge, you can use built-in string functions such as </span><span class="CodeSnippet" style="font-family:Times, serif">split()</span><span>.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Climbing Stairs</span></p><p style="line-height:115%"><span>Speros walks the stairs at the Dojo multiple times every day. Often he takes 2 stairs at a time, to work his quadriceps; he’s just that way. </span><span>Other days </span><span>he mixes it up: </span><span>with every </span><span>footstep,</span><span> he </span><span>randomly </span><span>chooses to take 1 stair or 2. </span><span>You </span><span>are</span><span> given an integer </span><span>representing</span><span> the total number of </span><span>stairs</span><span>. Determine all ways to walk the stairs. Given </span><span class="CodeSnippet" style="font-family:Times, serif">4</span><span>, return </span><span class="CodeSnippet" style="font-family:Times, serif">[[1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2]]</span><span>. Solve recursively with no loops. And don’t forget to get </span><span style="font-style:italic">yourself</span><span> some exercise during the bootcamp, as well. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span style="font-weight:bold">Second:</span><span> assuming you always start with a left foot, return only those ways that </span><span style="font-style:italic">end with a right step</span><span>.</span><span> </span><span>So,</span><span> given </span><span class="CodeSnippet" style="font-family:Times, serif">4</span><span>, </span><span>you should </span><span>return </span><span class="CodeSnippet" style="font-family:Times, serif">[[1,1,1,1], [2,2]]</span><span>. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span style="font-weight:bold">Third:</span><span> </span><span>instead of only returning those that end with a right step, only return those where the total number of steps climbed with left foot equal those climbed with right. </span><span>So,</span><span> given </span><span class="CodeSnippet" style="font-family:Times, serif">4</span><span>, you should return </span><span class="CodeSnippet" style="font-family:Times, serif">[[1,1,1,1], [1,2,1], [2,2]]</span><span>. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 9</span><span> – Recursion </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p class="Normal1"><span>This </span><span>chapter</span><span> you will familiarize yourself with recursion. Some or all of the following important concepts will be used in this </span><span>chapter’</span><span>s challenges.</span></p><p class="Normal1" style="line-height:normal"><span>&#xa0;</span></p><p class="Normal1"><span style="font-style:italic">B</span><span style="font-style:italic">ase </span><span style="font-style:italic">C</span><span style="font-style:italic">ases</span><span style="font-style:italic">F</span><span style="font-style:italic">orward </span><span style="font-style:italic">P</span><span style="font-style:italic">rogress</span><span style="font-style:italic">C</span><span style="font-style:italic">all </span><span style="font-style:italic">S</span><span style="font-style:italic">tack</span><span style="font-style:italic">Memoization</span><span style="font-style:italic">D</span><span style="font-style:italic">ynamic </span><span style="font-style:italic">P</span><span style="font-style:italic">rogramming</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Sum of Squares</span></p><p style="line-height:115%"><span>Mike enjoys teaching the “lego concept” to beginning HTML/CSS students</span><span>: breaking </span><span>a web page into different </span><span>rectangles</span><span>. There is something about squares that appeals to his sense of balance. Given </span><span>an </span><span>integer, calculate and print all combinations of </span><span style="font-style:italic">square integers</span><span> that sum to that integer. No duplicates are allowed among smaller integers. </span><span class="CodeSnippet" style="font-family:Times, serif">sumOfSquares(10)</span><span> =&gt; “1 + 9”. </span><span class="CodeSnippet" style="font-family:Times, serif">sumOfSquares(30)</span><span> =&gt; “1 + 4 + 25, 1 + 4 + 9 + 16”. Solve recursively with no loops. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">All Valid N Pairs of Parens</span></p><p class="Normal1" style="line-height:115%"><span>Given the number of pairs of parentheses, return an array of strings, where each string represents a different valid way to order those parentheses. </span><span>Example:</span><span> given </span><span class="CodeSnippet" style="font-family:Times, serif">2</span><span>, return </span><span class="CodeSnippet" style="font-family:Times, serif">["()()", "(())"]</span><span>.</span><span> </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Towers of Hanoi</span></p><p class="Normal1"><span>Create an algorithm to solve the Towers of Hanoi game. In the Towers of Hanoi, there are three poles and a stack of disks that fit onto the poles. The disks range from largest (on bottom) to smallest (on top), currently all on pole A. Moving only one disk at a time, move the stack to pole C. You can use any of the three poles you wish. A larger disk can never be placed on top of a smaller disk. How many moves does it take to relocate six disks from pole A to pole C? What is the first move? </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">IP Addresses</span></p><p class="Normal1" style="line-height:115%"><span>Given string containing digits, add three decimal points to convert into a valid IP address, and return that string. Each of the four </span><span style="font-style:italic">quads</span><span> in a </span><span class="CodeSnippet" style="font-family:Times, serif">"###.###.###.###"</span><span> IP address is a number between 0 and 255. Given </span><span class="CodeSnippet" style="font-family:Times, serif">"255255255"</span><span>, you could return </span><span class="CodeSnippet" style="font-family:Times, serif">"2.55.255.255"</span><span>, </span><span>or </span><span class="CodeSnippet" style="font-family:Times, serif">"25.5.255.255"</span><span>, or others. </span></p><p class="Normal1"><span style="font-weight:bold">Second:</span><span> return an array of </span><span style="font-style:italic">all possible</span><span> valid IP address combinations</span><span>, for the given string</span><span>. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Uneven Digits</span></p><p style="line-height:115%"><span>Cami doesn’t know why, but she’s just in an odd mood today. Let’s make all numerals odd for her. Given an integer, recursively return the integer formed by stripping out all even digits in original. Solve without loops. </span><span class="CodeSnippet" style="font-family:Times, serif">uneven(-1845)</span><span> = -15; </span><span class="CodeSnippet" style="font-family:Times, serif">uneven(79)</span><span> = 79; </span><span class="CodeSnippet" style="font-family:Times, serif">uneven(20)</span><span> = 0; </span><span class="CodeSnippet" style="font-family:Times, serif">uneven(-92)</span><span> = -9. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Generate All Possible Coin Change</span></p><p style="line-height:115%"><span>Create</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">generate</span><span class="CodeSnippet" style="font-family:Times, serif; text-decoration:underline">All</span><span class="CodeSnippet" style="font-family:Times, serif">CoinChange(cents)</span><span>. Given </span><span>a</span><span> number of American cents, compute and return an array enumerating </span><span>all</span><span> possible way</span><span>s</span><span> to represent </span><span>it,</span><span> with pennies (1 cent), nickels (5 cents), dimes (10 cents), quarters (25 cents). </span><span>For</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">5</span><span>, return </span><span class="CodeSnippet" style="font-family:Times, serif">[{</span><span class="CodeSnippet" style="font-family:Times, serif">dimes:0,nickels:1,pennies:0,quarters:0</span><span class="CodeSnippet" style="font-family:Times, serif">},</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif">dimes:0,nickels:0,pennies:5,quarters:0</span><span class="CodeSnippet" style="font-family:Times, serif">}{}]</span><span>.</span><span> Do not return duplicate results. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 9</span><span> – Recursion </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p class="Normal1"><span>Some of t</span><span>h</span><span>ese</span><span> </span><span>end-of-chapter</span><span> challenges all assume that you have some familiarity with the game </span><span style="font-style:italic">chess</span><span>. If you don</span><span>’</span><span>t, here is all you need to know. Chessboards are square, with 8 rows of 8 squares each. Queens are one type of chess piece, and in a single move they can travel any number of squares in either of the horizontal directions (along a </span><span style="font-style:italic">row</span><span>), or either of the vertical directions (along a </span><span style="font-style:italic">file</span><span> or </span><span style="font-style:italic">column</span><span>), or either of the diagonal directions. A piece is considered under threat from a queen if it is situated in a square w</span><span>here that queen can directly move.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Is</span><span style="font-size:0.86em"> </span><span style="font-size:0.86em">Chess</span><span style="font-size:0.86em"> </span><span style="font-size:0.86em">Move</span><span style="font-size:0.86em"> </span><span style="font-size:0.86em">Safe</span></p><p class="Normal1" style="line-height:115%"><span style="font-family:Times, serif; font-weight:bold">isChessMoveSafe(intendedMove,queen)</span><span> </span><span>returns </span><span class="CodeSnippet" style="font-family:Times, serif">true</span><span> if </span><span>square is threatened</span><span>, else </span><span class="CodeSnippet" style="font-family:Times, serif">false</span><span>. </span><span>It takes </span><span>a</span><span> location</span><span> object </span><span>for both the square to check, and current location of opposing queen.</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">Second</span><span style="font-weight:bold">:</span><span> accept</span><span> an</span><span> </span><span style="font-style:italic">array of queens</span><span>. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Eight Queens</span></p><p class="Normal1"><span>Build </span><span style="font-family:Times, serif; font-weight:bold">eightQueens()</span><span> using previous solutions</span><span>. Return all arrangements of eight queens on an 8x8 chessboard, so no queen threatens any other. </span><span>How would you best</span><span> return these results?</span><span> </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span style="font-weight:bold">Second</span><span style="font-weight:bold">:</span><span> write a helper function that displays the </span><span>queens-located-on-the-board </span><span>results returned</span><span>, in awesomely-retro character graphics</span><span>, using </span><span class="CodeSnippet" style="font-family:Times, serif">console.log()</span><span>.</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">All</span><span style="font-size:0.86em"> </span><span style="font-size:0.86em">Safe</span><span style="font-size:0.86em"> </span><span style="font-size:0.86em">Chess</span><span style="font-size:0.86em"> </span><span style="font-size:0.86em">Squares</span></p><p class="Normal1"><span>Build on your solution to the previous challenge, to create </span><span style="font-family:Times, serif; font-weight:bold">allSafeChessSquares(queen)</span><span> that returns all chessboard squares not threatened by a given queen.</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">Second</span><span style="font-weight:bold">:</span><span> accept an </span><span style="font-style:italic">array of queens</span><span>. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">N Queens</span></p><p class="Normal1"><span>Create </span><span style="font-family:Times, serif; font-weight:bold">nQueens(n,</span><span style="font-family:Times, serif; font-weight:bold">xSize</span><span style="font-family:Times, serif; font-weight:bold">,</span><span style="font-family:Times, serif; font-weight:bold">ySize</span><span style="font-family:Times, serif; font-weight:bold">)</span><span> </span><span>using previous work, </span><span>returning all arrangements of N unthreatened queens on X </span><span>by</span><span> Y rectangular board. </span><span style="font-family:Times, serif; font-weight:bold">eightQueens()</span><span> == </span><span style="font-family:Times, serif; font-weight:bold">nQueens(8,8,8)</span><span>.</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span style="font-weight:bold">Second:</span><span> optimize your solution so that you can extend </span><span class="CodeSnippet" style="font-family:Times, serif">n</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">xSize</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">ySize</span><span> as far as possible before you exhaust the available memory. Can you get as high as 15 queens on a 15x15 board? </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 9</span><span> – Recursion </span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Where’s the Bug? (recursion version)</span></p><p><span>Without peeking at previous code, how many bugs can you find in the recursive code below?</span><span> </span></p><p><span>&#xa0;</span></p><p class="Code" style="text-indent:0pt"><span>function rFib(num)</span></p><p class="Code" style="text-indent:0pt"><span>{</span></p><p class="Code"><span>if (num &lt;= 1) { return 1; }</span></p><p class="Code"><span>&#xa0;</span></p><p class="Code"><span>return rFib(num) + rFib(num - 1);</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p><p class="Code" style="text-indent:0pt"><span>&#xa0;</span></p><p class="Code" style="text-indent:0pt"><span>function rListLength(node) {</span></p><p class="Code"><span>if (!node) {</span></p><p class="Code" style="margin-left:36pt; text-indent:0pt"><span>return 0;</span></p><p class="Code"><span>}</span></p><p class="Code"><span>else {</span></p><p class="Code" style="margin-left:36pt; text-indent:0pt"><span>return rListLength(node.next);</span></p><p class="Code"><span>}</span></p><p class="Code"><span>return rListLength(node) + 1;</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p><p class="Code" style="text-indent:0pt"><span>&#xa0;</span></p><p class="Code" style="text-indent:0pt"><span>function rSigma(num)</span></p><p class="Code"><span>if (num == 0) { return 0; }</span></p><p class="Code"><span>return num + rSigma(num - 1);</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p><p class="Code" style="text-indent:0pt"><span>&#xa0;</span></p><p class="Code" style="text-indent:0pt"><span>function rFactorial(num) {</span></p><p class="Code"><span>if (num === 0) {return 0; }</span></p><p class="Code"><span>return rFactorial(num + 1) * num; </span></p><p class="Code" style="text-indent:0pt"><span>}</span></p><p><br style="page-break-before:always; clear:both" /></p></div></body></html>