<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_101"><span>Repairing a Binary Search Tree</span></h2><p style="line-height:115%"><span>If it is possible with </span><span class="CodeSnippet" style="font-family:Times, serif">isValid()</span><span> to detect whether a </span><span class="CodeSnippet" style="font-family:Times, serif">B</span><span class="CodeSnippet" style="font-family:Times, serif">T</span><span class="CodeSnippet" style="font-family:Times, serif">N</span><span class="CodeSnippet" style="font-family:Times, serif">ode</span><span> is in an incorrect location, then it should also be possible to repair an invalid </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>. Unfortunately, once we find an invalid node, we have no guarantee about the nodes below it – so our only recourse is to reinsert all of the subtree nodes (not just the one node we found to be invalid). </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: Repair</span></p><p style="line-height:115%"><span>Sometimes it is hard to find good help. Oscar is working with a third-party library that receives data from outside sources and sorts it into a binary search tree. Oscar is positive the library has bugs, because sometimes the BSTs it produces don’t meet the requirements of a </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>. Given a potentially invalid </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> object, create a standalone function </span><span class="CodeSnippet" style="font-family:Times, serif">bstRepair(</span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> that rearranges nodes as needed to make it valid. Return </span><span class="CodeSnippet" style="font-family:Times, serif">true</span><span> if you repaired the </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>,</span><span> or</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">false</span><span> if this was not needed. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: Smallest Difference</span></p><p class="Normal1" style="line-height:115%"><span>Given a valid </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>, return the smallest difference between any two values in the tree. What are the run-time and space complexities of your solution? </span><span>Would it be less efficient if </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> was very unbalanced? </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">SList: </span><span style="font-size:0.86em">Smallest Difference</span></p><p class="Normal1"><span>Given sorted singly linked list, return the smallest difference between values. What are the run-time and space complexities of your solution? </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: Closest </span><span style="font-size:0.86em">Value (again)</span></p><p class="Normal1" style="line-height:115%"><span>Given valid </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> and number, return the tree value closest to that number. What are the run-time and space complexities of your solution? </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">SList: </span><span style="font-size:0.86em">Closest </span><span style="font-size:0.86em">Value</span></p><p class="Normal1" style="line-height:115%"><span>Given sorted </span><span class="CodeSnippet" style="font-family:Times, serif">SList</span><span> and number, return the list value closest to that number. What are the run-time and space complexities of your solution? </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Array: </span><span style="font-size:0.86em">Closest </span><span style="font-size:0.86em">Value</span></p><p class="Normal1"><span>Given </span><span>sorted array</span><span> and number</span><span>, return the </span><span>array value closest to that number</span><span>. What are the run-time and space complexities of your solution? </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">DList: </span><span style="font-size:0.86em">Closest </span><span style="font-size:0.86em">Value</span></p><p class="Normal1" style="line-height:115%"><span>Given sorted </span><span class="CodeSnippet" style="font-family:Times, serif">DList</span><span> and number, return the list value closest to that number. What are the run-time and space complexities of your solution?</span><span> </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Normal1"><span>For this particular problem, which of the data structures </span><span>mentioned above </span><span>will most likely lead to optimal performance in finding the closest value</span><span>, across a diverse data set</span><span>? How would you pre-process the values – potentially storing them in a different data structure – if </span><span>optimal run-time performance was your primary goal, and you were willing to consume significant amounts of memory in order to achieve it? </span></p><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 15</span><span> – Trees, Part II</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>