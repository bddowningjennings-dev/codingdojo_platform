<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_68"><span>Data Sufficiency</span></h2><p><span>One important </span><span>problem solving </span><span>concept is the idea of </span><span style="font-style:italic">data sufficiency</span><span>. In algorithm challenges </span><span>and </span><span>real-world problems, </span><span>having </span><span>a piece of data doesn’t necessarily </span><span>make it </span><span>important. Often code will run faster if </span><span>we </span><span>discard </span><span>unneeded </span><span>data. In fact, sometimes your code </span><span style="font-style:italic">cannot</span><span> run </span><span style="font-style:italic">until</span><span> you let go of </span><span>it</span><span>! </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Last Digit of A to the B</span></p><p><span>Modern computers can handle very large numbers, but they do have their limits. A number that is repeatedly multiplied by itself will eventually exceeds </span><span>a</span><span> computer’s ability to accurately represent it. (</span><span>N</span><span>ote: the number of times it is multiplied by itself is called </span><span>an</span><span> </span><span style="font-style:italic">exponent</span><span>.) For an optional end-of-chapter challenge, determine the smallest (least significant) digit of a number that is potentially very, very large. You may find that you </span><span>must</span><span> do this without computing the actual (unimaginably large) number. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Implement a function </span><span class="CodeSnippet" style="font-family:Times, serif">lastDigitAtoB(a,b)</span><span> </span><span>that accepts two non-negative integers. </span><span>It</span><span> should return the last digit of </span><span>a number found by raising </span><span>the first number (</span><span class="CodeSnippet" style="font-family:Times, serif">a</span><span>) to an exponent of the second number (</span><span class="CodeSnippet" style="font-family:Times, serif">b</span><span>). Examples: given </span><span class="CodeSnippet" style="font-family:Times, serif">(3,4)</span><span>, you should return </span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span> (</span><span>3 * 3 * 3 * 3 is 81, whose last digit is 1</span><span>). Given </span><span class="CodeSnippet" style="font-family:Times, serif">(12,5)</span><span>, return </span><span class="CodeSnippet" style="font-family:Times, serif">2</span><span> (</span><span>which is the</span><span> least significant digit of 248832</span><span>: </span><span>12 * 12 * 12 * 12 * 12). How high can you scale your solution? For example, what is the return value for </span><span class="CodeSnippet" style="font-family:Times, serif">(237,124)</span><span>?</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Matrix Search</span></p><p class="Normal1"><span>Mike digs image recognition and wants to create </span><span>a</span><span> JavaScript Imaging Library, just like PIL for Python. He</span><span> </span><span>is</span><span> given 2 different two-dimensional arrays, containing integers between 0 and 65535</span><span>. </span><span>Each two-dimensional array represents a </span><span>gray-scale</span><span> image, where each integer value is a pixel</span><span>. </span><span>The second </span><span>image</span><span> </span><span style="font-style:italic">might</span><span> be </span><span>found somewhere within</span><span> the larger one</span><span>. </span><span>Return whether </span><span>it is</span><span>. </span></p><p class="Normal1" style="text-indent:36pt"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%; text-indent:36pt"><span>Given </span><span>array</span><span>:</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">[</span><span class="CodeSnippet" style="font-family:Times, serif">[</span><span class="CodeSnippet" style="font-family:Times, serif">12,34,45,56</span><span class="CodeSnippet" style="font-family:Times, serif">],</span><span> </span><span>and </span><span>array</span><span>:</span><span class="CodeSnippet" style="font-family:Times, serif">[</span><span class="CodeSnippet" style="font-family:Times, serif">[</span><span class="CodeSnippet" style="font-family:Times, serif">67,78</span><span class="CodeSnippet" style="font-family:Times, serif">],</span><span>return </span><span class="CodeSnippet" style="font-family:Times, serif">true</span><span>.</span></p><p class="Normal1" style="line-height:115%; margin-left:108pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">[</span><span class="CodeSnippet" style="font-family:Times, serif">98,87,76,65</span><span class="CodeSnippet" style="font-family:Times, serif">],</span><span class="CodeSnippet" style="font-family:Times, serif">[43,32]]</span></p><p class="Normal1" style="line-height:115%; margin-left:108pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">[</span><span class="CodeSnippet" style="font-family:Times, serif">56,</span><span class="CodeSnippet" style="font-family:Times, serif; text-decoration:underline">67</span><span class="CodeSnippet" style="font-family:Times, serif">,</span><span class="CodeSnippet" style="font-family:Times, serif; text-decoration:underline">78</span><span class="CodeSnippet" style="font-family:Times, serif">,89</span><span class="CodeSnippet" style="font-family:Times, serif">],</span></p><p class="Normal1" style="line-height:115%; margin-left:90pt; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">[54,</span><span class="CodeSnippet" style="font-family:Times, serif; text-decoration:underline">43</span><span class="CodeSnippet" style="font-family:Times, serif">,</span><span class="CodeSnippet" style="font-family:Times, serif; text-decoration:underline">32</span><span class="CodeSnippet" style="font-family:Times, serif">,21]]</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span style="font-weight:bold">Second</span><span style="font-weight:bold">:</span><span> </span><span>Return location of first match found (</span><span class="CodeSnippet" style="font-family:Times, serif">[-1,-1]</span><span> if no match). In example above, return </span><span class="CodeSnippet" style="font-family:Times, serif">[2,1]</span><span>.</span><span> </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Max </span><span style="font-size:0.86em">of</span><span style="font-size:0.86em"> Subarray Sums</span></p><p class="Normal1"><span>How efficient can you be</span><span> on this following final challenge</span><span>? The input </span><span>may hold many million </span><span>values. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span>Given a numerical array that is potentially very long, return the m</span><span>aximum sum of values from a sub</span><span>array. Any </span><span style="font-style:italic">consecutive sequence </span><span>of indices i</span><span>n the array is considered a sub</span><span>array. Create a function that returns the highest sum possible from these subarrays. Given </span><span class="CodeSnippet" style="font-family:Times, serif">[1,2,-4,3,-2,3,-1]</span><span>, you should return </span><span style="font-weight:bold">4</span><span> (</span><span>for subarray</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">[3,-2,3]</span><span>), and given </span><span class="CodeSnippet" style="font-family:Times, serif">[-1,-2,-4,-3,-2,-3]</span><span>, return </span><span style="font-weight:bold">0</span><span> (for </span><span class="CodeSnippet" style="font-family:Times, serif">[]</span><span>). This problem has many possible implementations</span><span>. </span><span>Which do you prefer &amp; why?</span><br style="page-break-before:always; clear:both" /></p></div></body></html>