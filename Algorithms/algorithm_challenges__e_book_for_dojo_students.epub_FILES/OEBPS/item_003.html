<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_57"><span>Linked Lists Review</span></h2><p style="line-height:115%"><span style="font-weight:bold">Objects</span><span> are a collection of attributes and functions. Because they are variable in size, they are allocated in the </span><span style="font-weight:bold">memory heap</span><span>. Object constructors return </span><span style="font-weight:bold">p</span><span style="font-weight:bold">ointers</span><span>, which are fixed in size and hence can be </span><span>held in local variables. Conceptually, a pointer is just some particular memory location (not unlike “P.O. Box 5588”), referring to a location </span><span>in the heap</span><span> where some object has been allocated. Although calling </span><span class="CodeSnippet" style="font-family:Times, serif">console.log()</span><span> on some</span><span> variable containing a pointer will display the contents of the allocated object, this is only because the browser is trying to be helpful – the actual contents of that variable </span><span>(the pointer itself) </span><span>is merely a </span><span>number representing some memory </span><span>location (not what is </span><span style="font-style:italic">stored</span><span> at that location). </span><span style="font-style:italic">D</span><span style="font-style:italic">ereferenc</span><span style="font-style:italic">ing</span><span> a pointer </span><span>means traveling </span><span>across it</span><span>,</span><span> to the attributes and functions within the object on the other side</span><span>. To dereference an object pointer</span><span>, append </span><span class="CodeSnippet" style="font-family:Times, serif">.</span><span> plus an attribute name. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>A </span><span style="font-weight:bold">linked list</span><span> is a sequence of connected </span><span style="font-weight:bold">node</span><span> objects. Nodes contain </span><span class="CodeSnippet" style="font-family:Times, serif">.next</span><span> pointers, plus </span><span>other attributes as needed. </span><span>In our examples, node objects often contain only </span><span class="CodeSnippet" style="font-family:Times, serif">.val</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">.next</span><span>, but in real-world scenarios you find much larger objects with dozens of attributes, </span><span style="font-style:italic">including</span><span> a </span><span class="CodeSnippet" style="font-family:Times, serif">.next</span><span> so that these object records can be sequenced, grouped and sorted. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Linked l</span><span>ists are preferable to arrays if frequently adding/removing values mid-sequence. Unlike arrays, </span><span>singly linked </span><span>lists directly access only the first node – to reach later ones, we </span><span style="font-weight:bold">traverse</span><span> </span><span>from one node to the next one by following the sequence of </span><span class="CodeSnippet" style="font-family:Times, serif">.next</span><span> pointers. Singly linked lists have the ability to traverse only forward through the list, because they contain only a single link between nodes. A doubly linked list </span><span>is comprised of nodes containing both </span><span class="CodeSnippet" style="font-family:Times, serif">.next</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">.prev</span><span> pointers, and for this reason they are useful when we need to traverse back and forth in our sequence; that said, doubly linked lists are slightly more complicated to build and maintain (as we will see in a future chapter). </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">alert</span><span class="CodeSnippet" style="font-family:Times, serif">()</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">prompt</span><span class="CodeSnippet" style="font-family:Times, serif">()</span><span> are useful in debugging and quick prototypes, but not customer-facing views. </span></p><p><span>&#xa0;</span></p><p><span>Creating </span><span style="font-weight:bold">clear, understandable code</span><span> is well worth the effort </span><span>needed, because this code is more easily and quickly understood, and can be extended with more confidence</span><span>. </span><span>Taking the time to do this is the professional way to approach any code, and it is doing any future engineer in your code a favor. </span><span>Do it! </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><br style="page-break-before:always; clear:both" /></p></div></body></html>