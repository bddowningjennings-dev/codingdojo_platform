<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_118"><span>Breadth-First Search</span></h2><p><span>If depth-first search is </span><span style="font-style:italic">impulsive</span><span> – choosing a path and “not looking back” until the string of possibilities is disproved – then breadth-first search (BFS) is </span><span style="font-style:italic">methodical</span><span> and almost </span><span style="font-style:italic">cautious</span><span>. With BFS, we visit vertices based on how close they are to the source. In an interconnected graph, this is similar to ripples spreading on a pond. When is breadth-first useful, compared to depth-first?</span></p><p><span>&#xa0;</span></p><p><span>Say we want to find shortest path from vertex D to vertex J. With DFS, we would determine all possible paths, then compare lengths. The last path DFS explores might turn out to be shortest. BFS, however, guarantees to explore options from closest, outward. As soon as we find a valid path, we know it is optimal – maybe </span><span style="font-style:italic">one of many</span><span>, but nonetheless optimal. BFS is ideal for </span><span style="font-style:italic">find shortest path</span><span> </span><span>problems. </span></p><p><span>&#xa0;</span></p><p><span>In another example, our graph resembles a mostly complete binary tree structure. A number of the vertices contain a specific value, and we are searching for any of them, starting from a ‘root’ vertex. (From what we know so far, either BFS or DFS are reasonable choices.) Further, we know that </span><span style="font-style:italic">all the vertices we seek are leaves</span><span>. Now, DFS is a </span><span style="font-style:italic">clear</span><span> choice. Here’s why: if graph resembles complete BST, with BFS we won’t reach leaf vertices until after traversing </span><span style="font-style:italic">all</span><span> intermediate vertices (guaranteed to be 50% of graph), whereas with DFS we get to leaf vertices as soon as possible. In worst </span><span>case,</span><span> both approaches still check the entire graph, but in best case DFS finds a target almost immediately. DFS also wins in average case: based on number of targets, this linearly scales between best and worst. </span></p><p><span>&#xa0;</span></p><p><span>What enables BFS to work outward evenly, compared to DFS? Hint: something in the algorithm is inherently more </span><span style="font-style:italic">fair</span><span> than the DFS algorithm. In </span><span style="font-style:italic">D</span><span style="font-style:italic">FS</span><span>, we use a Stack to store the possibilities that we want to explore. When one path is exhausted, we next explore the path </span><span style="font-style:italic">most recently </span><span style="font-style:italic">discovered</span><span>. This takes DFS “down toward the leaves” and keeps it there, rather than evenly expanding our ripples on the pond. It would be more </span><span style="font-style:italic">fair</span><span> to explore paths from first-discovered to last-discovered. So, which data structure should we use? </span><span style="font-style:italic">Queues</span><span> are ‘fair’ data structures and used in BFS for this reason. In fact, this is usually the </span><span style="font-style:italic; text-decoration:underline">only</span><span> change needed, to convert a DFS algorithm to a BFS one!</span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Shortest Path</span></p><p style="line-height:115%"><span>Given an unweighted graph as well as IDs for source and destination vertices, find a path that requires minimal fewest edges. Return this path as an array of vertex IDs, or </span><span class="CodeSnippet" style="font-family:Times, serif">[]</span><span> if no path exists. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Gimme</span><span style="font-size:0.86em"> Three Steps</span></p><p><span>Given undirected graph and ID for start vertex, return IDs for vertices three or fewer edges away. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Easy </span><span style="font-size:0.86em">to</span><span style="font-size:0.86em"> Get There</span></p><p class="Normal1" style="line-height:115%"><span>Given directed graph, return </span><span class="CodeSnippet" style="font-family:Times, serif">[vertID]</span><span> for vertices with more incoming edges than outgoing edges. </span></p><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 17</span><span> – Graphs</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p class="Normal1"><span>You built graph representations, solved shortest-path problems, maybe even visited </span><span style="text-decoration:underline">oracleofbacon.org</span><span> or </span><span style="text-decoration:underline">6degreesofvincegill.com</span><span>. Now what? Let’s talk about graphs with and without </span><span style="font-style:italic">cycles</span><span>.</span></p><p><span>&#xa0;</span></p><p><span>In graphs, unlike binary trees, a vertex can have inbound edges from multiple source vertices. Does this create a cycle? Not necessarily! A graph does not necessarily have a single ‘ancestor’ vertex from where all paths originate. What if node A had two children B and C, and they both pointed to the same vertex D – is </span><span style="font-style:italic">that</span><span> a cycle? Again, not necessarily. Recall: some (most) graphs are </span><span style="font-style:italic">directed</span><span>, meaning edges have direction. The existence of paths ABD and ACD does not create a cycle (unless graph is </span><span style="font-style:italic">undirected</span><span>: ABD would imply DBA, which along with ACD creates a cycle.) A cycle is a path that starts and ends with the same vertex, not revisiting any intervening vertices. </span><span style="font-weight:bold">Cyclic graphs</span><span>, then, </span><span style="font-style:italic">might</span><span> have cycles, whereas </span><span style="font-weight:bold">acyclic graphs</span><span> are guaranteed to have none. What does this give us?</span></p><p><span>&#xa0;</span></p><p><span>For one, undirected graphs that contain </span><span style="font-style:italic">as many edges as vertices</span><span> must be cyclic (although if there are fewer edges, this doesn’t prove it is acyclic). Counting edges is one way to “fail-fast” when determining if a graph is cyclic. On the </span><span style="font-style:italic">directed</span><span> graph side, all acyclic graphs must have at least one vertex without inbound edges, as well as at least one vertex with no outbound edges – if the graph does not contain both, we know it is cyclic (although again, the existence of these vertices doesn’t prove it is acyclic). </span></p></div></body></html>