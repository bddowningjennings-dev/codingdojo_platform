<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h1 id="navPoint_79"><img src="item_067.png" width="216" height="65" alt="" style="float:left; margin:0pt 9pt" /><span>Chapter 11</span><span> – Trees</span></h1><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p class="Normal1"><span>This </span><span>chapter</span><span> we </span><span>explore</span><span> </span><span>trees, and in particular </span><span style="font-weight:bold">binary search tree</span><span> (BST),</span><span> a</span><span>n</span><span> important data structure. </span><span>The BST</span><span> is optimized for quickly finding</span><span>/</span><span>retrieving elements. A BST is similar to a linked list, in that it stores data elements within node objects. Let</span><span>’</span><span>s compare a </span><span style="font-style:italic">doubly l</span><span style="font-style:italic">inked list node </span><span>to a </span><span style="font-style:italic">binary tree node</span><span>. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Code" style="text-indent:0pt"><span>function </span><span>DLNode</span><span>(value) {</span></p><p class="Code"><span>this.val = value;</span></p><p class="Code"><span>this.prev = null;</span></p><p class="Code"><span>this.next = null;</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p><p class="Code" style="text-indent:0pt"><br style="mso-column-break-before:always; clear:both" /><span>function </span><span>BTNode</span><span>(value) {</span></p><p class="Code"><span>this.val = value;</span></p><p class="Code"><span>this.left = null;</span></p><p class="Code"><span>this.right = null;</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>In a </span><span style="font-style:italic">doubly linked list</span><span>, each node has a value, plus pointers to two peers (</span><span style="font-style:italic">prev</span><span> and </span><span style="font-style:italic">next</span><span>). Similarly, in a </span><span style="font-weight:bold">binary tree </span><span>each node has a </span><span style="font-weight:bold">value</span><span>, plus pointers to two children, </span><span style="font-weight:bold">left</span><span> and </span><span style="font-weight:bold">right</span><span>. Just as with linked lists, these pointer attributes often reference another node, but can be null. Linked lists and binary trees always start with a single node; </span><span>in</span><span> a linked list we call it the head, </span><span>in</span><span> a binary tree</span><span> we call it the root. The BST </span><span style="font-style:italic">structures the data </span><span>in a tree rather than a flat linear sequence. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>A</span><span> binary tree node can have a l</span><span>eft child and/or a right child; </span><span>each child might have left and/or right children of </span><span>its</span><span> own. </span><span>A</span><span>n entire section of a family </span><span>might descend from one sibling</span><span> as opposed to another, similarly there are related subsets of a binary tree. These are (</span><span>no surprise</span><span>) called </span><span style="font-style:italic">subtrees</span><span>. We refer to all nodes stemming from the root node</span><span>’</span><span>s left pointer as the root</span><span>’</span><span>s left subtree, for example. </span><span>By their basic definition, neither generic b</span><span>inary tree</span><span>s nor generic </span><span>linked list</span><span>s</span><span> </span><span>impose any specific order on where values must be located in them. There </span><span style="font-style:italic">is</span><span> a type of binary tree that adds structure, though</span><span>. Read on. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>The </span><span style="font-weight:bold">binary </span><span style="font-weight:bold; text-decoration:underline">search</span><span style="font-weight:bold"> tree</span><span> adds a requirement that for </span><span>every</span><span> node, all </span><span>nodes in its left subtree </span><span>must have </span><span>smaller values</span><span>. Similarly</span><span>, its right subtree must contain only values that are </span><span>greater than or equal to </span><span>its</span><span> value. </span><span>T</span><span>his constraint holds for every node in the subtree, not just the direct child</span><span>ren</span><span>. </span><span>These rules determine</span><span> exactly where new children are placed in a BST. If </span><span>“</span><span>Grandparent</span><span>”</span><span> node</span><span>&lt;50&gt; </span><span>has a right child with </span><span>the </span><span>value 75, then children of node</span><span>&lt;75&gt;</span><span> are appropriately constrained</span><span> not only by their parent, but by that grandparent as well</span><span>. Specifically, </span><span>the entire left subtree of node&lt;75&gt; must have values between 50 and 75.</span><span> </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>BST nodes </span><span>without children</span><span> are considered </span><span style="font-style:italic">leaf</span><span> nodes</span><span>. Depending on </span><span>its</span><span> values, no node is required to have two children. Even in a tree containing many values, the root node might have a </span><span style="font-style:italic">left</span><span> or </span><span style="font-style:italic">right</span><span> pointer that is null (</span><span>e.g. </span><span>if th</span><span>e</span><span> root contains the smallest or largest value in the tree, respectively). </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>The Binary Search Tree is an example of an </span><span style="font-style:italic">Ordered</span><span> data structure, because the values are stored in a way that allows us </span><span>easily </span><span>to get from one value to the next-largest value or next-smallest value. </span></p><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 11</span><span> – Trees</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>Let’s build a basic Binary Search Tree. These</span><span> challenges </span><span>start with</span><span> the following reference definitions:</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Code" style="text-indent:0pt"><span>function </span><span>BTNode</span><span>(value) {</span></p><p class="Code"><span>this.val = value;</span></p><p class="Code"><span>this.left = null;</span></p><p class="Code"><span>this.right = null;</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p><p class="Code" style="text-indent:0pt"><br style="mso-column-break-before:always; clear:both" /><span>function </span><span>BST</span><span>() {</span></p><p class="Code"><span>this.root = null;</span></p><p class="Code"><span>// add methods here...</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Normal1"><span>&#xa0;</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: Add</span></p><p style="line-height:115%"><span>Create a</span><span>n </span><span class="CodeSnippet" style="font-family:Times, serif">add(val)</span><span> method on the </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> object to add </span><span>new value to the tree. This entails creating a </span><span class="CodeSnippet" style="font-family:Times, serif">BTNode</span><span> with this value and connecting it at the appro</span><span>priate place in the tree. Unless specified otherwise, </span><span>BST</span><span>s can contain duplicate values. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: Min</span></p><p style="line-height:115%"><span>Create a </span><span class="CodeSnippet" style="font-family:Times, serif">min()</span><span> method on the </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> class that returns the smallest value found in the </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>.</span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: Size</span></p><p style="line-height:115%"><span>Write a </span><span class="CodeSnippet" style="font-family:Times, serif">size()</span><span> method that returns the number of nodes (values) contained in the tree. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: C</span><span style="font-size:0.86em">ontains</span></p><p style="line-height:115%"><span>Create a </span><span class="CodeSnippet" style="font-family:Times, serif">contains(val)</span><span> </span><span>method on </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> that returns whether the tree contains a given value. Take advantage of the </span><span>BST</span><span> structure to make this a much more rapid operation than </span><span class="CodeSnippet" style="font-family:Times, serif">SList</span><span class="CodeSnippet" style="font-family:Times, serif">.contains()</span><span> would be.</span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: M</span><span style="font-size:0.86em">ax</span></p><p style="line-height:115%"><span>Create a </span><span class="CodeSnippet" style="font-family:Times, serif">max()</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> method that returns the largest value</span><span> contained in the binary search tree</span><span>.</span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: I</span><span style="font-size:0.79em">s</span><span style="font-size:0.86em"> Empty</span></p><p style="line-height:115%"><span>Create a</span><span>n </span><span class="CodeSnippet" style="font-family:Times, serif">isEmpty()</span><span> method </span><span>to return whether</span><span> </span><span>the </span><span>BST</span><span> is empty (</span><span>whether it </span><span>contains no values).</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 11 – Trees</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>You may have already realized that all Binary Search Trees are not equivalent. The arrangement of the nodes in the tree have a real effect on its efficiency. In referring to a tree’s shape, we use the terms </span><span style="font-style:italic">depth</span><span> (also known as </span><span style="font-style:italic">height</span><span>) and </span><span style="font-style:italic">balance</span><span>, and a few chapters down the road we will work with trees of certain shapes that we refer to as </span><span style="font-style:italic">full</span><span> and </span><span style="font-style:italic">complete</span><span>. Let us explore these terms further. </span></p><p><span>&#xa0;</span></p></div></body></html>