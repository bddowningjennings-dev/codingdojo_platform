<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_138"><span>The Performance Journey</span></h2><p><span>Software performance can be really difficult to get right. Just as there are many facets of what can slow down a piece of software, there are many avenues that you can pursue to improve it. Probably the most important</span><span> first step</span><span>, though, it simply to quantify the </span><span>existing </span><span>performance of </span><span>that </span><span>code. What are the important Metrics That Matter? Is it a server module</span><span>,</span><span> where </span><span style="font-style:italic">throughput</span><span> is </span><span>king</span><span>? Is it a client feature, where </span><span>customers</span><span> are most likely to value </span><span style="font-style:italic">responsiveness</span><span>? Choose the right metrics, then measure</span><span>, </span><span style="font-style:italic">measure</span><span>, </span><span style="font-style:italic; font-weight:bold">measure</span><span>. </span><span>Measure </span><span>all the time – when adding new features, changing th</span><span>ings</span><span>, </span><span>or</span><span> fixing bugs. There’s no telling when </span><span>a</span><span> well-intentioned bug fix will undo an important set of performance tuning. </span></p><p><span>&#xa0;</span></p><p><span>Using this performance system</span><span>,</span><span> </span><span style="font-style:italic">set performance goals</span><span>. These should be explicit and well-understood before anyone goes off </span><span>on</span><span> some crazy performance overhaul. Goals are specific and quantifiable, and once you reach them, you don’t </span><span>need</span><span> to (</span><span>and </span><span>usually </span><span style="font-style:italic">should not</span><span>) optimiz</span><span>e </span><span>further. Code is </span><span>often</span><span> most understandable </span><span>when first written; </span><span>any </span><span>optimization takes us </span><span>away</span><span> from that </span><span>easily</span><span>-understood state. </span></p><p><span>&#xa0;</span></p><p><span>Before starting optimization, compare </span><span>your goals </span><span>with your </span><span>current state. Get a feel for how far away you are. If you need a small improvement, </span><span>go with more tactical, low-risk, </span><span>high-confidence</span><span> tweaks</span><span>. If you need a big improvement, you’re likely going to need to pull all the levers you can find. </span></p><p><span>&#xa0;</span></p><p><span>There are many different altitudes at which you can engage in performance optimization. Design level, algorithm level, code tuning, and more. </span><span>Design changes are </span><span>the most disruptive. Naturally</span><span>,</span><span> the best time to make a design-level course correction is before (much) code has been written. Don’t be afraid to work on paper to demonstrate that the system really </span><span style="font-style:italic">can</span><span> scale the way your design intends. A back of the envelope sketch to double-check things might save multiple person-years of work down the line. </span></p><p><span>&#xa0;</span></p><p><span>Let’s work through </span><span>three challenges/solutions</span><span>. </span><span>Each includes a sequence of small improvements</span><span>, </span><span>along with narration to take you through the optimization thought process. Y</span><span>ou </span><span>will </span><span>benefit most if you </span><span>create fully coded solutions for each step along the </span><span>way</span><span>, before referring to the next page</span><span>. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Closest Three-Sum (Series)</span></p><p style="line-height:115%"><span>Given an assorted array of numbers, plus a </span><span class="CodeSnippet" style="font-family:Times, serif">target</span><span> number, return the three array elements whose sum is closest to </span><span class="CodeSnippet" style="font-family:Times, serif">target</span><span>. For example, given </span><span class="CodeSnippet" style="font-family:Times, serif">([1,8,5,10,2,4,3],6)</span><span>, return </span><span class="CodeSnippet" style="font-family:Times, serif">[1,2,3]</span><span>.</span><span> </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Closest Three-Sum (Series)</span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline"> – continued</span></p><p style="line-height:115%"><span>How did you test your solution? Before optimizing, ensure your code works. Did you try inputs with less than three elements? Do you ensure array elements can only appear once in the </span><span style="font-style:italic">result trio</span><span>? The inputs </span><span class="CodeSnippet" style="font-family:Times, serif">([1,4,6,7],3)</span><span> should return </span><span class="CodeSnippet" style="font-family:Times, serif">[1,4,6]</span><span>, </span><span style="font-style:italic">not</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">[1,1,1]</span><span>. If you have correctness confidence, continue. </span></p><p><span>&#xa0;</span></p><p><span>Next, examine your solution’s performance, and characterize it with Big-O. How much space does it require? What about run-time performance? Did you make unnecessary assumptions? Below we list one possible answer to this challenge. What is your analysis of this solution? </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Calculate sums, determine which are closest to target, and return them.</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function closestT</span><span class="CodeSnippet" style="font-family:Times, serif">hreeSum1(arr, target) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var sums = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx1 = 0; idx1 &lt; arr.length; idx1++) </span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">sums[idx1] = [];</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx2 = 0; idx2 &lt; arr.length; idx2++) </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">sums[idx1][idx2] = [];</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx3 = 0; idx3 &lt; arr.length; idx3++) </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">sums[idx1][idx2][idx3] = arr[idx1] + arr[idx2] + arr[idx3];</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestSum = Number.MAX_VALUE;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestNums = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx1 = 0; idx1 &lt; arr.length; idx1++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx2 = 0; idx2 &lt; arr.length; idx2++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx3 = 0; idx3 &lt; arr.length; idx3++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if ((target - sums[idx1][idx2][idx3]) &lt; bestSum) </span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestSum = target - sums[idx1][idx2][idx3];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[0] = arr[idx1];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[1] = arr[idx2];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[2] = arr[idx3];</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return bestNums;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:1.09em; line-height:115%"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Closest Three-Sum (Series)</span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline"> – continued</span></p><p style="line-height:115%"><span>We hope you share our opinion that </span><span class="CodeSnippet" style="font-family:Times, serif">closestThreeSum1</span><span> is … unfortunate. It has a number of significant problems. First, it does not actually work because of the absence of two </span><span class="CodeSnippet" style="font-family:Times, serif">Math.abs()</span><span> calls. Can you identify where these should be? Also, it is susceptible to crash if sent incorrect inputs. We must fix those before considering any optimization. At that point, what are our performance goals? </span></p><p><span>&#xa0;</span></p><p><span>Let’s say our goals are to return a correct answer for 2000-element arrays in 10 milliseconds (ms), and to successfully scale to handle 1,000,000-element arrays in less than an hour. The previous code, after being fixed, fails on both accounts. It returns the answer for 300-element array in 386ms, and it crashes Chrome when trying to handle a 515-element array (solves 514-element array in 1963ms). We’re a long way from those goals! What are the major problems leading to this abysmal outcome? At a glance they might be: memory consumption and (</span><span style="font-style:italic">two different sets of</span><span>) nested loops. Which should we tackle first? </span></p><p><span>&#xa0;</span></p><p><span>Memory consumption is often our worst culprit</span><span>. To </span><span>quantify its impact, let’s eliminate the second nested set of loops altogether. We could continue to create a large three-dimensional array, but instead of calculating the answer after-the-fact, we could keep track of the best-so-far as we go (there would be little need to create the large array at that point, but stay with me). This only improves performance by about 5%. If we eliminate the array, performance is much better: 65ms for 300 elements, and 300ms for 514 elements! Plus, we scale further: for 2000 elements, we require 17828ms. Code is below:</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function closestThreeSum2(arr, target) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr === undefined || target === undefined) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr.length === undefined || arr.length &lt; 3) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestSum = Number.MAX_VALUE;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestNums = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx1 = 0; idx1 &lt; arr.length; idx1++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx2 = 0; idx2 &lt; arr.length; idx2++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx3 = 0; idx3 &lt; arr.length; idx3++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var sum = Math.abs(arr[idx1] + arr[idx2] + arr[idx3] - target);</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (sum &lt; bestSum) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestSum = sum;</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[0] = arr[idx1];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[1] = arr[idx2];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[2] = arr[idx3];</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return bestNums;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p style="font-size:1.09em; line-height:115%"><span style="font-size:0.92em">If our goal is 10ms (not 17000) for a 2000-element array, then we still have work to do!</span><span style="text-decoration:underline"> </span></p><p style="font-size:1.09em; line-height:115%"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Closest Three-Sum (Series)</span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline"> – continued</span></p><p style="line-height:115%"><span>Actually, the solution above is still incorrect. It will put a single array element into the solution multiple times. We need to adjust our </span><span class="CodeSnippet" style="font-family:Times, serif">FOR</span><span> loops so that this does not occur. Related, the </span><span class="CodeSnippet" style="font-family:Times, serif">idx1</span><span> outer loop does not need to extend out to </span><span class="CodeSnippet" style="font-family:Times, serif">arr.length</span><span>, since </span><span class="CodeSnippet" style="font-family:Times, serif">idx2</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">idx3</span><span> will always be after it. Those could be:</span></p><p><span>&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx1 = 0; idx1 &lt; arr.length - 2; idx1++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx2 = idx1 + 1; idx2 &lt; arr.length - 1; idx2++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx3 = idx2 + 1; idx3 &lt; arr.length; idx3++) {</span></p><p><span>&#xa0;</span></p><p><span>Also, must we continue if we find a combination that matches our target exactly? No, in that case let’s fast-finish. This would result in our having the following code. What is your assessment now? </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function closestThreeSum4(arr, target) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr === undefined || target === undefined) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr.length === undefined || arr.length &lt; 3) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestSum = Number.MAX_VALUE;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestNums = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx1 = 0; idx1 &lt; arr.length - 2; idx1++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx2 = idx1 + 1; idx2 &lt; arr.length - 1; idx2++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx3 = idx2 + 1; idx3 &lt; arr.length; idx3++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var sum = Math.abs(arr[idx1] + arr[idx2] + arr[idx3] - target);</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (sum &lt; bestSum) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[0] = arr[idx1];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[1] = arr[idx2];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[2] = arr[idx3];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (sum === 0) { return bestNums; }</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestSum = sum;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return bestNums;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>The </span><span class="CodeSnippet" style="font-family:Times, serif">FOR</span><span> loop adjustment improves our 2000-element performance to 2.989 seconds (from 17). The fast-return is harder to quantify, but for integer arrays it usually returns in </span><span style="font-style:italic">much</span><span> less than a millisecond (0.008ms in some tests). If the values are not integers, however, our performance is unchanged unless we change </span><span class="CodeSnippet" style="font-family:Times, serif">(sum === 0)</span><span> to something like </span><span class="CodeSnippet" style="font-family:Times, serif">(sum &lt; 0.0001)</span><span>. Let’s say we really do want to find the very best match, so must leave this as-is. We must focus on bringing the 2.989-seconds number down. What about a totally different approach? Think about this before going on to the next page. </span></p><p style="font-size:1.09em; line-height:115%"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Closest Three-Sum (Series)</span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline"> – continued</span></p><p><span>If we are already operating at</span><span> </span><span style="font-weight:bold">O(n</span><span style="font-size:0.67em; font-weight:bold; vertical-align:super">3</span><span style="font-weight:bold">)</span><span>, then there is little harm in sorting the input array (unless this is forbidden by the interviewer). If the array is sorted, does that help? </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>If array is sorted, </span><span>the sum will increase </span><span>as we progress through each loop. For our innermost loop, once </span><span class="CodeSnippet" style="font-family:Times, serif">sum</span><span> exceeds </span><span class="CodeSnippet" style="font-family:Times, serif">target</span><span>, we won’t get any closer, so we should break out of that particular inner loop. What performance gain would you expect from this optimization? Are there drawbacks? Code is below: </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function closestThreeSum5s(arr, target) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr === undefined || target === undefined) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr.length === undefined || arr.length &lt; 3) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestSum = Number.MAX_VALUE;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestNums = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">selectionSort(arr);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx1 = 0; idx1 &lt; arr.length - 2; idx1++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx2 = idx1 + 1; idx2 &lt; arr.length - 1; idx2++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx3 = idx2 + 1; idx3 &lt; arr.length; idx3++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var sum = arr[idx1] + arr[idx2] + arr[idx3] - target;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var absSum = Math.abs(sum);</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (absSum &lt; bestSum) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[0] = arr[idx1];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[1] = arr[idx2];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[2] = arr[idx3];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (absSum === 0) { return bestNums; }</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestSum = absSum;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">else {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (sum &gt; 0) { break; }</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return bestNums;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p><span>What would you change about the above? At this speed, it would take four years to handle a million-element array – not exactly the speed we want. What about performance on our 2000-element goal? </span></p><p><span>&#xa0;</span></p><p><span>Good news and bad news. For floating-point values, we get almost 2x speedup! However, for 2000-integer arrays, performance moves from &lt;0.01ms to 6ms – a 600x slowdown! Not good, right? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Closest Three-Sum (Series)</span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline"> – continued</span></p><p style="line-height:115%"><span>Don’t be distracted by attempts to lure your focus away from your performance goals. This is still good, assuming our goals remain 1) correctly handle 2000-element arrays in 10ms, and 2) correctly handle 1-million-element arrays in 60 minutes. Nonetheless, it is good to understand the cause of the slowdown. Even if the first three elements yield a fast-finish result, we have a guaranteed cost of sorting the array (6 ms to </span><span class="CodeSnippet" style="font-family:Times, serif">selectionSort</span><span> 2000 elements). </span><span>Substituting </span><span class="CodeSnippet" style="font-family:Times, serif">quickSort</span><span> </span><span>for </span><span class="CodeSnippet" style="font-family:Times, serif">selectionSort</span><span> eliminates </span><span>about 2 ms, giving us 1650 ms for 2000 floats, or 4 ms for 2000 integers. Not bad, but not there yet. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>What else would take advantage of the fact that the array is sorted? Techniques like </span><span style="font-style:italic">binary-search</span><span> can find a value much faster than linear iteration. Could we do that with </span><span class="CodeSnippet" style="font-family:Times, serif">idx3</span><span>? The code below uses binary-search to narrow in on an ideal </span><span class="CodeSnippet" style="font-family:Times, serif">idx3</span><span> value, moving on when </span><span class="CodeSnippet" style="font-family:Times, serif">low</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">high</span><span> bookends come together. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function closestThreeSum6q(arr, target) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr === undefined || target === undefined) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr.length === undefined || arr.length &lt; 3) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestSum = Number.MAX_VALUE;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestNums = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">quickSort(arr);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx1 = 0; idx1 &lt; arr.length - 2; idx1++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx2 = idx1 + 1; idx2 &lt; arr.length - 1; idx2++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var high = arr.length - 1;</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var low = idx2 + 1;</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">while (high &gt;= low) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var idx3 = Math.floor((high + low) / 2);</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var candidateSum = arr[idx1] + arr[idx2] + arr[idx3] - target;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var absDiff = Math.abs(candidateSum);</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (absDiff &lt; bestSum) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[0] = arr[idx1]; </span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[1] = arr[idx2]; </span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[2] = arr[idx3];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (absDiff === 0) { return bestNums; }</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">bestSum = absDiff;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (candidateSum &gt; 0) { high = idx3 - 1; } </span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">else { low = idx3 + 1; }</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return bestNums; </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">} </span></p><p><span>&#xa0;</span></p><p><span>Theoretically, this takes </span><span>us</span><span> from</span><span> </span><span style="font-weight:bold">O(n</span><span style="font-size:0.67em; font-weight:bold; vertical-align:super">3</span><span style="font-weight:bold">)</span><span> </span><span>to </span><span style="font-weight:bold">O(n</span><span style="font-size:0.67em; font-weight:bold; vertical-align:super">2</span><span style="font-weight:bold">logn)</span><span>, </span><span>which is </span><span>a 100x win </span><span>if we have </span><span>2000 elements….</span><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Closest Three-Sum (Series)</span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline"> – continued</span></p><p style="line-height:115%"><span>This makes a big difference! For 2000 floats, we </span><span>now </span><span>run in 71ms, which </span><span>starts</span><span> to approach our 10ms goal. Integers run in 0.225ms, which is fantastic. Unfortunately, extrapolating to 1 million elements, we still require more than 10 hours to run</span><span>: w</span><span>e need more</span><span> perf wins</span><span>. How about the </span><span class="CodeSnippet" style="font-family:Times, serif">Math.floor</span><span> call? Aren’t those expensive? We get a 10% speedup by </span><span>instead using</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">&gt;&gt;&gt;</span><span> (</span><span class="CodeSnippet" style="font-family:Times, serif">closestThreeSum7q</span><span>, not shown), but that won’t give us an order-of-magnitude improvement. </span><span>We</span><span> need a better way to scale up. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Rather than code tuning, our answer </span><span>lies in</span><span> another algorithmic breakthrough. Have </span><span class="CodeSnippet" style="font-family:Times, serif">idx2</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">idx3</span><span> count toward each other as follows: start </span><span class="CodeSnippet" style="font-family:Times, serif">idx2</span><span> at </span><span class="CodeSnippet" style="font-family:Times, serif">idx1+1</span><span>; start </span><span class="CodeSnippet" style="font-family:Times, serif">idx3</span><span> at </span><span class="CodeSnippet" style="font-family:Times, serif">arr.length-1</span><span>. If the three-way sum is too small, move </span><span class="CodeSnippet" style="font-family:Times, serif">idx2</span><span> up by one, otherwise move </span><span class="CodeSnippet" style="font-family:Times, serif">idx3</span><span> down by one. For each </span><span class="CodeSnippet" style="font-family:Times, serif">idx2</span><span>, there are very few </span><span class="CodeSnippet" style="font-family:Times, serif">idx3</span><span> values worth considering. This reduces the </span><span class="CodeSnippet" style="font-family:Times, serif">idx2|idx3</span><span> inner loops from </span><span class="CodeSnippet" style="font-family:Times, serif">O(N</span><span class="CodeSnippet" style="font-family:Times, serif">log</span><span class="CodeSnippet" style="font-family:Times, serif">N</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> to </span><span class="CodeSnippet" style="font-family:Times, serif">O(2</span><span class="CodeSnippet" style="font-family:Times, serif">N</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> – a big win, and perhaps enough to meet our goals! The code would look like this:</span><span> </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function closestThreeSum8q(arr, target) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr === undefined || target === undefined) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (arr.length === undefined || arr.length &lt; 3) { return; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestSum = Number.MAX_VALUE;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var bestNums = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">quickSort(arr);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx1 = 0; idx1 &lt; arr.length - 2; idx1++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var idx2 = idx1 + 1;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var idx3 = arr.length - 1;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">while (idx2 &lt; idx3) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var candidateSum = arr[idx1] + arr[idx2] + arr[idx3] - target;</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var absDiff = Math.abs(candidateSum);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (absDiff &lt; bestSum) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[0] = arr[idx1]; </span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[1] = arr[idx2]; </span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">bestNums[2] = arr[idx3];</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (absDiff === 0) { return bestNums; }</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">bestSum = absDiff;</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (candidateSum &gt; 0) { idx2++; } else { idx3--; }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return bestNums; </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p><span>What do you predict? Could a simple change like this really make a noticeable change? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Closest Three-Sum (Series)</span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline"> – continued</span></p><p style="line-height:115%"><span>Success! For a 2000-element array of floats, </span><span class="CodeSnippet" style="font-family:Times, serif">closestThreeSum8q</span><span> handles them in 5.46ms (down from 62). For integers, our performance is up to 4.3ms, but this is still within range. This actually suggests performance of straight-up </span><span style="font-weight:bold">O(n</span><span style="font-size:0.67em; font-weight:bold; vertical-align:super">2</span><span style="font-weight:bold">)</span><span>, which suggests that we would handle a million-element array in 1350 seconds, or only 22 minutes. Could this be the case? Yes – in less than 24 minutes, our function returns. From </span><span class="CodeSnippet" style="font-family:Times, serif">closestThreeSum1</span><span> </span><span>to this one, we sped the 500-element case by 5000x. For </span><span class="CodeSnippet" style="font-family:Times, serif">closestThreeSum2</span><span>, a million-element array would take 70 years. </span><span>The </span><span class="CodeSnippet" style="font-family:Times, serif">8q</span><span> function</span><span> ma</span><span>kes</span><span> it 5.46ms. </span></p><p><span>&#xa0;</span></p><p><span>Bottom line: </span><span>Algorithm choice is truly crucial when optimizing software. This is particularly the case in your most central, highly-frequented inner-loop code locations. Here, a tiny win can be magnified into significant savings. The Big-O decision does and should overshadow other decisions here</span><span>. O</span><span>nce you </span><span>have achieved </span><span>the right order of magnitude to meet your goals, identifying </span><span>additional </span><span>ways to cut your runt</span><span>ime in half can give huge gains</span><span> even if </span><span>your Big-O</span><span> doesn’t change. People will still notice. </span></p><p><span>&#xa0;</span></p><p><span>The next challenge explores two axes simultaneously – improving performance, and adding features. Enhancements range from algorithm to data structure to plain old logic. We hope you enjoy the ride. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">N Queens (Series)</span></p><p class="Normal1"><span>Recall this challenge from </span><span>earlier material</span><span> on recursion. </span><span>Chessboards are square, with 8 rows of 8 squares each. Queens are one type of chess piece, and in a single move they can travel any number of squares in either of the horizontal directions (along a </span><span style="font-style:italic">row</span><span>), or either of the vertical directions (along a </span><span style="font-style:italic">file</span><span> or </span><span style="font-style:italic">column</span><span>), or either of the diagonal directions</span><span> (staying on the same color)</span><span>. A piece is considered </span><span style="font-style:italic">under threat</span><span> from a queen if it is situated in a square w</span><span>here that queen can directly move.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Chess Move Safe</span></p><p class="Normal1" style="line-height:115%"><span style="font-family:Times, serif; font-weight:bold">isChessMoveSafe(intendedMove,</span><span style="font-family:Times, serif; font-weight:bold">queenArr</span><span style="font-family:Times, serif; font-weight:bold">)</span><span> </span><span>returns </span><span class="CodeSnippet" style="font-family:Times, serif">true</span><span> if </span><span>square is threatened</span><span>, else </span><span class="CodeSnippet" style="font-family:Times, serif">false</span><span>. </span><span>Accepts location</span><span> object </span><span>to check, and current locations of an array of opposing queens. </span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens</span></p><p style="line-height:115%"><span>Create </span><span style="font-family:Times, serif; font-weight:bold">nQueens(n</span><span style="font-family:Times, serif; font-weight:bold">umQns</span><span style="font-family:Times, serif; font-weight:bold">,</span><span style="font-family:Times, serif; font-weight:bold">xSize</span><span style="font-family:Times, serif; font-weight:bold">,</span><span style="font-family:Times, serif; font-weight:bold">ySize</span><span style="font-family:Times, serif; font-weight:bold">)</span><span> </span><span>using previous work such as </span><span class="CodeSnippet" style="font-family:Times, serif">isChessMoveSafe</span><span>, </span><span>returning all arrangements </span><span>of N unthreatened queens on X-by-</span><span>Y rectangular board. </span><span style="font-family:Times, serif; font-weight:bold">eightQueens()</span><span> == </span><span style="font-family:Times, serif; font-weight:bold">nQueens(8,8,8)</span><span>.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><span>&#xa0;</span></p><p><span>As with earlier </span><span>challenges, it behooves you to solve it on your own before moving on to the next page. Refresh your memory by revisiting the Recursion </span><span>material</span><span>, if needed. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued </span></p><p><span>Again, it benefits you most if you have already created a solution before reading on. If not, do so now. </span><span>Did</span><span> </span><span>the previous performance journey change how you viewed this one? For this challenge, we start with a most ridiculous implementation. Do your best to spot the fix or optimization before we get to it! </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isChessMoveSafe1(intendedMove, queenArr) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var xCoord = 0, yCoord = 1;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var safe = true;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var qNum = 0; qNum &lt; queenArr.length; qNum++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var row = 0; row &lt; 8; row++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if ((intendedMove[xCoord] == row) </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">&amp;&amp;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">(intendedMove[yCoord] == queenAr</span><span class="CodeSnippet" style="font-family:Times, serif">r[qNum][yCoord])) { safe=false;</span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; 8; col++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if ((intendedMove[xCoord] == queenArr[qNum][xCoord])</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">&amp;&amp;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">(intendedMove[yCoord] == col)) { safe = false; }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var lDiag = -7; lDiag &lt;= 7; lDiag++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if ((</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">intendedMove[xCoord] </span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">-</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">intendedMove[yCoord] == lDiag)</span></p><p style="line-height:115%; margin-left:18pt; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">&amp;&amp;</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">(queenArr[qNum][xCoord] </span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">- </span><span class="CodeSnippet" style="font-family:Times, serif">queenArr[qNum][yCoord] == lDiag)) </span></p><p style="line-height:115%; margin-left:18pt; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{ safe = false; }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var rDiag = 0; rDiag &lt;= 14; rDiag++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if ((</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">intendedMove[xCoord]</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">+</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">intendedMove[yCoord] == rDiag)</span></p><p style="line-height:115%; margin-left:18pt; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">&amp;&amp;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif"> (queenArr[qNum][xCoord]</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">+ </span><span class="CodeSnippet" style="font-family:Times, serif">queenArr[qNum][yCoord] == rDiag))</span></p><p style="line-height:115%; margin-left:18pt; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{ safe = false; }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return safe;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function queens1(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft,results,queensSoFar) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (results === undefined)</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif"> results = [];</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (queensSoFar === undefined)</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">{ queensSoFar = [];</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var row = 0; row &lt; 8; row++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; 8; col++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (isChessMoveSafe1([row, col], queensSoFar)) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var newQueen = [row,col];</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">qu</span><span class="CodeSnippet" style="font-family:Times, serif">eens1(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft-1,results,</span><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.concat([newQueen]));</span></p><p style="line-height:115%; margin-left:54pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">} else { results.push(queensSoFar); }</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p style="line-height:115%"><span>First, we’re sorry about the previous page’s code. It is a bit below Dojo standards, in performance but also in correctness. Perhaps you spot the bugs already, but first let’s talk about what this code is </span><span style="font-style:italic">trying</span><span> to do. This is a typical recursive approach for the Eight Queens problem</span><span>. To </span><span>identify a location, we use a two-element array. Using a technique known as dynamic programming, the </span><span class="CodeSnippet" style="font-family:Times, serif">queens1</span><span> function calls itself, building up an array of queens in safe locations. When all the required queens are placed, it adds the </span><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar</span><span> array to the final </span><span class="CodeSnippet" style="font-family:Times, serif">results</span><span> array, and then it </span><span>backtrace</span><span>s</span><span> in order to continue. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Good idea, but unfortunately the code is dreadful</span><span>. To </span><span>determine all the ways of placing just 5 queens on an 8x8 board, it took more than 30 seconds – and it returned the wrong answer (do you see why?). There are duplicates in the results returned, because regardless of where we may have put the previous queen, we always start at the top row when suggesting the next set of safe squares. This may be the right thing if we are creating an </span><span class="CodeSnippet" style="font-family:Times, serif">allSafeChessSquares</span><span> function, but here we don’t want that. So, our first change will be to address a </span><span style="font-style:italic">defect</span><span>: once we put down a queen, </span><span style="font-style:italic">don’t allow subsequent queens to be placed on earlier rows</span><span>. </span></p><p><span>&#xa0;</span></p><p><span>The following code at least functions correctly:</span></p><p style="font-size:0.73em; line-height:115%"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function queens2(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft,results,queensSoFar) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (results === undefined) </span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">{ results = []; </span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (queensSoFar === undefined) { queensSoFar = []; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var row = 0;</span></p><p style="line-height:115%; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (queensSoFar.length) { </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">row = queensSoFar[queensSoFar.length - 1][0]; </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for ( ; row &lt; 8; row++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; 8; col++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (isChessMoveSafe1([row, col], queensSoFar)) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queens2(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft-1,</span><span class="CodeSnippet" style="font-family:Times, serif"> </span></p><p style="line-height:115%; margin-left:144pt"><span class="CodeSnippet" style="font-family:Times, serif">results,</span></p><p style="line-height:115%; margin-left:144pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.concat([[row,col]])</span></p><p style="line-height:115%; margin-left:108pt; text-indent:31.5pt"><span class="CodeSnippet" style="font-family:Times, serif">);</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">else {</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">results.push(queensSoFar);</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p><span>What else is hiding in here that we should address? Let’s measure performance. How do you think this version will compare to the previous one? The previous one took about 30 seconds to find ways to place 5 queens on an 8x8 board. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p style="line-height:115%"><span>The new version </span><span class="CodeSnippet" style="font-family:Times, serif">queens2</span><span> only took 310 milliseconds (ms) to correctly return the 46736 possible ways of placing 5 queens on an 8x8 board. Now that we have code that actually runs correctly, let’s crank it all the way up to 8 queens. The </span><span class="CodeSnippet" style="font-family:Times, serif">queens2</span><span> version, when run with 8 queens on an 8x8 board, requires 720 milliseconds to return the correct 92 solutions. By the way, you may be wondering how we make these timing measurements. Our initial profiling code looks like the following:</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function timeQueens1(num) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var start, end;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var results = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">start = Date.now();</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">results = queens1(num);</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">// or queens2, etc.</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">end = Date.now();</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">console.log("Found %d solns in %f m</span><span class="CodeSnippet" style="font-family:Times, serif">illisec", results.length, end-</span><span class="CodeSnippet" style="font-family:Times, serif">start);</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span>So, how </span><span style="font-style:italic">about</span><span> that </span><span class="CodeSnippet" style="font-family:Times, serif">queens2</span><span> function? It runs a lot faster, yes? It does, but not fast enough. There are a couple of things that leap out; let’s handle them. One, we “check for undefined” in every recursive call. Let’s move that out of our main recursion path into a wrapper function. Two, when adding a queen to our </span><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar</span><span> collection, we don’t resume on the </span><span style="font-style:italic">next</span><span> row, we resume on the</span><span style="font-style:italic"> same</span><span> row. Those squares will never be fruitful, so it’s wasted time. If you haven’t seen </span><span class="CodeSnippet" style="font-family:Times, serif">FOR</span><span> loops with blank initialization sections, those </span><span style="font-style:italic">are</span><span> legal, if uncommon. Also, the </span><span style="font-style:italic">double-</span><span class="CodeSnippet" style="font-family:Times, serif; font-style:italic">[</span><span> within </span><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.concat</span><span> is intentional. Without them, </span><span class="CodeSnippet" style="font-family:Times, serif">concat</span><span> will think we want to append those two elements to </span><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar</span><span>, instead of appending the array itself. After making those fixes, let’s try the following updated </span><span class="CodeSnippet" style="font-family:Times, serif">queens3</span><span>:</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function queens3(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft,results,queensSoFar) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var row = 0;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (queensSoFar.length) { </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">row = queensSoFar[queensSoFar.length - 1][0] + 1; </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for ( ; row &lt; 8; row++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; 8; col++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (isChessMoveSafe1([row, col], queensSoFar)) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queens3(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">-</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">1,</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">results,</span><span class="CodeSnippet" style="font-family:Times, serif"> </span></p><p style="line-height:115%; margin-left:144pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.concat([[row,col]]));</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">} else { results.push(queensSoFar); }</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p><span>What do you predict? Remember, the previous version correctly ran 8 queens in 720 ms. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">Queens3</span><span> is our best attempt so far, without question. It correctly runs 8 queens in 262 milliseconds! Something is still rotten in the state of our code</span><span>, however</span><span>. Earlier on, did you happen to raise an eyebrow at our </span><span class="CodeSnippet" style="font-family:Times, serif">isChessMoveSafe</span><span> function? Honestly, it’s about as inefficient as possible. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Here’s a much-improved final version of </span><span class="CodeSnippet" style="font-family:Times, serif">isChessMoveSafe</span><span>:</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isChessMoveSafe(intendedMove, queenArr) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">!(intendedMove</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">instanceof Array)</span></p><p style="line-height:115%; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">||</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">!(queenArr</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span class="CodeSnippet" style="font-family:Times, serif">instanceof Array)) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var qNum = 0; qNum &lt; queenArr.length; qNum++) {</span></p><p style="font-size:0.95em; line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">       </span><span class="CodeSnippet" style="font-family:Times, serif">      </span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">intendedMove[0]==queenArr[qNum][0]</span></p><p style="font-size:0.95em; line-height:115%; margin-left:36pt; text-indent:13.5pt"><span class="CodeSnippet" style="font-family:Times, serif">||</span><span class="CodeSnippet" style="font-family:Times, serif">          </span><span class="CodeSnippet" style="font-family:Times, serif">       </span><span class="CodeSnippet" style="font-family:Times, serif">intendedMove[1]==queenArr[qNum][1]</span></p><p style="font-size:0.95em; line-height:115%; margin-left:36pt; text-indent:13.5pt"><span class="CodeSnippet" style="font-family:Times, serif">|| intendedMove[0]+intendedMove[1]==queenArr[qNum][0]+queenArr[qNum][1]</span></p><p style="font-size:0.95em; line-height:115%; margin-left:36pt; text-indent:13.5pt"><span class="CodeSnippet" style="font-family:Times, serif">|| intendedMove[0]-intendedMove[1]==queenArr[qNum][0]-queenArr[qNum][1]</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">)</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{ return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p><span>Oh my, much better. </span><span>Instead of</span><span> 168 array reads, this has 12. </span><span>Previously </span><span>62 compares, </span><span>now is</span><span> 4. </span><span>Our </span><span>30 adds and 30 subtracts</span><span> </span><span>became</span><span> 2 adds and 2 subtracts. Best of all, </span><span>we have</span><span> a fast-fail</span><span>:</span><span> the numbers cited are </span><span style="font-style:italic">worst-case</span><span>. This function </span><span>is called </span><span style="font-style:italic; text-decoration:underline">constantly</span><span>. We sh</span><span>ould expect significant speedup, yes?</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Our </span><span class="CodeSnippet" style="font-family:Times, serif">queens4</span><span> function is essentially unchanged, other than calling the above improved subroutine:</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function queens4(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft,results,queensSoFar) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var row = 0;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (queensSoFar.length)</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{ </span><span class="CodeSnippet" style="font-family:Times, serif">row</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">=</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">queensS</span><span class="CodeSnippet" style="font-family:Times, serif">oFar[queensSoFar.length - 1][0] + </span><span class="CodeSnippet" style="font-family:Times, serif">1;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for ( ; row &lt; 8; row++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; 8; col++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (isChessMov</span><span class="CodeSnippet" style="font-family:Times, serif">eSafe([row, col], queensSoFar)) </span><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queens4(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft-1,results,q</span><span class="CodeSnippet" style="font-family:Times, serif">ueensSoFar.concat([[row,col]]))</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">} else { results.push(queensSoFar); }</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p><span>What next? Will our performance improve? Have we introduced bugs? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p style="line-height:115%"><span>So far so good with our performance journey. The </span><span class="CodeSnippet" style="font-family:Times, serif">queens4</span><span> function (powered by </span><span class="CodeSnippet" style="font-family:Times, serif">isChessMoveSafe</span><span>) runs in 62 millisec, a </span><span style="font-style:italic; text-decoration:underline">major</span><span> (12x) improvement from our initial 720 ms version (and that doesn’t count our original version that ran in 30 </span><span>secs</span><span> and didn’t even work right). Where do we go from here – are we done? No! The original challenge asked us to extended our code out as far as we could, to faster times and larger boards. If we don’t yet see how to tune this code further, then we can at least extend it from hard-coded 8-by-8 dimensions to arbitrary X-by-Y dimensions. As we get faster, the larger boards can be a better barometer for measuring our progress. Let’s refactor </span><span class="CodeSnippet" style="font-family:Times, serif">queens</span><span> to handle any board size:</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function queens5(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft, xSize, ySize, results, queensSoFar) </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var row = 0;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (queensSoFar.length) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">row = queensSoFar[queensSoFar.length - 1][0] + 1;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for ( ; row &lt; ySize; row++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; xSize; col++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (isChessMoveSafe([row, col], queensSoFar)) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queens5(</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft - 1, xSize,</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">ySize, results, </span></p><p style="line-height:115%; margin-left:108pt; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.concat([[row,col]]));</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">else { results.push(queensSoFar); }</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>One additional thing. We will start using </span><span class="CodeSnippet" style="font-family:Times, serif">performance.now()</span><span> instead of </span><span class="CodeSnippet" style="font-family:Times, serif">Date.now()</span><span> in our timings. The </span><span class="CodeSnippet" style="font-family:Times, serif">Date</span><span> object is useful, but the newer </span><span class="CodeSnippet" style="font-family:Times, serif">performance</span><span> object is intended for exactly this sort of high-precision timing, and at this point </span><span>it </span><span>is available on all important browser versions. So, now if we measure performance, will we see a big win? What is our expected result? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p style="line-height:115%"><span>As expected, performance is </span><span style="font-style:italic">unchanged</span><span> between </span><span class="CodeSnippet" style="font-family:Times, serif">queens4</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">queens5</span><span> </span><span>– w</span><span>e only extended our game board to arbitrary sizes. However, now we can measure larger </span><span>boards</span><span>. 8x8: 56ms; 9x9: 402ms; 10x10: 3362ms; 11x11: 30383ms. As you </span><span>profile</span><span> your code, you may see ups and downs. Shut down programs to clear memory</span><span>, making your test environment </span><span>slightly more consistent. In the end, though, these readings will always have variability. </span><span>A </span><span>time-honored convention is to take multiple readings (perhaps </span><span>5</span><span>), th</span><span>row out the best and worst,</span><span> and average the rest. </span><span>The timings below do exactly that. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Now what? It would be good to retrieve a set of </span><span style="font-style:italic">next safe squares</span><span>, instead of continually asking about each different square – essentially, </span><span class="CodeSnippet" style="font-family:Times, serif">allSafeChessSquares</span><span>. My first version, </span><span class="CodeSnippet" style="font-family:Times, serif">nextChessSquares1</span><span> (not included), did not include our earlier bug fix, so after placing queens in lower rows, it subsequently offered first-row queens. Oops! While there, I added error checking to our wrapper function, in case someone asks for 10 queens on a 9x9 board, etc. Here are latest fixed versions of everything involved: </span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function nextChessSquares2(queenArr, x, y) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var safeSquares = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var row = (queenArr.length) ? queenArr[queenArr.length - 1][0] + 1 : 0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for ( ; row &lt; y; row++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; x; col++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">(isChessMoveSafe([row,col],</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">queenArr))</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">safeSquares.push([row,col]);</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return safeSquares;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function queens6(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft, x, y, results, queensSoFar) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var candidates = nextChessSquares2(queensSoFar, x, y);</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var candNum = 0; candNum &lt; candidates.length; candNum++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queens6(</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft - 1, x, y, results</span></p><p style="line-height:115%; margin-left:108pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.concat([candidates[candNum]]));</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">} else { results.push(queensSoFar); }</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span><span> </span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function nQueens2(num, x, y) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var results = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt;= x &amp;&amp; num &lt;= y) { queens6(num, x, y, results, []); }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return results;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">Queens6</span><span> looks good, but </span><span class="CodeSnippet" style="font-family:Times, serif">nextChessSquares2</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">nQueens2</span><span> are nothing new. Let’s measure.</span><span> </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p style="line-height:115%"><span>The measurements for </span><span class="CodeSnippet" style="font-family:Times, serif">queens6</span><span> are the same as those for </span><span class="CodeSnippet" style="font-family:Times, serif">queens5</span><span>. Remember that we created </span><span class="CodeSnippet" style="font-family:Times, serif">nextChessSquares</span><span> function to streamline the process of identifying candidates for the next queen? Within it, we just used the standard </span><span class="CodeSnippet" style="font-family:Times, serif">isChessMoveSafe</span><span>, which is why performance has not yet improved. We can optimize the checking of a square further, and that should help a lot, since this is done continuously. </span><span>First, we eliminate the function call by putting </span><span class="CodeSnippet" style="font-family:Times, serif">isChessMoveSafe</span><span> code </span><span style="font-style:italic; text-decoration:underline">inline</span><span> – into our </span><span class="CodeSnippet" style="font-family:Times, serif">nextChessSquares</span><span> function itself. </span><span>That by itself may not do a lot, but we can further eliminate one of the four checks as well: remember, we don’t have to do a row check any longer, since we will always start exploring on the row following the previous queen. That is, all queens are placed in successive rows on our board. With that, here is the tuned-up </span><span class="CodeSnippet" style="font-family:Times, serif">nextChessSquares</span><span> function:</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function nextChessSquares3(queenArr, x, y) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var safeSquares = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var row = (queenArr.length) ? queenArr[queenArr.length - 1][0] + 1 : 0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for ( ; row &lt; y; row++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; x; col++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var qNum = 0; qNum &lt; queenArr.length; qNum++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var qY = queenArr[qNum][0];</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var qX = queenArr[qNum][1];</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">qX == col</span></p><p style="line-height:115%; margin-left:72pt; text-indent:13.5pt"><span class="CodeSnippet" style="font-family:Times, serif">|| qX - qY == col </span><span class="CodeSnippet" style="font-family:Times, serif">–</span><span class="CodeSnippet" style="font-family:Times, serif"> row</span></p><p style="line-height:115%; margin-left:72pt; text-indent:13.5pt"><span class="CodeSnippet" style="font-family:Times, serif">|| qX + qY == col + row)</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">{ break; }</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (qNum == queenArr.length) { safeSquares.push([row,col]); }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return safeSquares;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p><span>Any predictions? This will be f</span><span>aster, presumably, but will it be a big win? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p><span>Well, the gain is measurable, but it isn’t a </span><span style="font-style:italic; text-decoration:underline">big</span><span> win – maybe 5% better (which is never bad). Our timings are as follows: 52.8ms for 8x8, 378.7</span><span> </span><span>ms for 9x9, 3159</span><span> </span><span>ms for 10x10, and 29234</span><span> </span><span>ms for 11x11. At this point we need a new approach. What about memory usage? Generally smaller is faster. Can we make things smaller? There are no obvious ways that jump out at us, on that. Well, what things are taking up memory? Our location arrays take up space. Also, our candidate location chains are coming and going all the time. Even if our memory needs stay constant, we could always try to reduce ongoing memory churn. Memory operators can be expensive, particularly in problems like this with big </span><span>backtrace</span><span> results. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>The change seems like a reasonable one, because we do see the </span><span class="CodeSnippet" style="font-family:Times, serif">candidates</span><span> array constantly growing and shrinking, as recursion/backtracing happens. We should not continually deallocate and reallocate that array; let’s keep it more stable. If we want to </span><span class="CodeSnippet" style="font-family:Times, serif">push</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">pop</span><span> it, that means we can’t add it ‘live’ to the results array, though. We’ll need to make a shallow copy each time we add a new final result. That is a very good tradeoff, since we </span><span class="CodeSnippet" style="font-family:Times, serif">push</span><span>/</span><span class="CodeSnippet" style="font-family:Times, serif">pop</span><span> candidates constantly, and only occasionally add a new final </span><span class="CodeSnippet" style="font-family:Times, serif">result</span><span> solution. </span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function q</span><span class="CodeSnippet" style="font-family:Times, serif">ueens8(n</span><span class="CodeSnippet" style="font-family:Times, serif">QueensLeft, x, y, results, queensSoFar) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var candidates = nextChessSquares3(queensSoFar, x, y);</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var candNum = 0; candNum &lt; candidates.length; candNum++)</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.push(candidates[candNum]);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queensTest(</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif"> - 1, x, y, results, queensSoFar);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.pop();</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">else {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">results.push(Array.from(queensSoFar));</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span>One additional note: I just read a post talking about the fastest way to make a copy of an array. </span><span>I expected that </span><span class="CodeSnippet" style="font-family:Times, serif">Array.from</span><span> would be the winner. Actually, it </span><span style="font-style:italic">isn’t</span><span> – doing it by hand is much better! </span><span>So,</span><span> we’ll change the one-liner (commented out below) to this chunk of code instead:</span></p><p style="font-size:0.73em; line-height:115%"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">//</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">results.push(Array.from(queensSoFar));</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var result = [];</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx = 0; idx &lt; queensSoFar.length; idx++) { </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">result[idx] = queensSoFar[idx]; </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">results.push(result);</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p><span>Let’s do a check-in on performance to see how far we’ve come. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p><span>Our </span><span style="font-style:italic">eliminate memory churn</span><span> fixes worked brilliantly. Our timings have experienced the first significant downtick in a while. We measure 14.4ms for 8x8, 98.1</span><span> </span><span>ms for 9x9, 825</span><span> </span><span>ms for 10x10, and 7387</span><span> </span><span>ms for 11x11. This is almost a 4x improvement, which is massive! Also, measuring separately, doing an array copy by hand </span><span style="font-style:italic">is</span><span> much faster than using a built-in. This saved us an entire second, on the 11x11. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Where now? Are we empty of ideas – is this as good as it gets? Believe it or not, there are three more </span><span class="CodeSnippet" style="font-family:Times, serif">queens</span><span> improvements out there to show us additional tuning! </span></p><p><span>&#xa0;</span></p><p><span>You know how we significantly reduced our time, by making sure to start exploring next queen locations </span><span style="font-style:italic">after</span><span> previous one? That eliminated lots of dead ends (and false duplicates). What about the flip side? It would not make sense, for example, to place a queen on the last row if we still have </span><span style="font-style:italic">two</span><span> queens to place after it! So, just as we can constrain the starting row for each candidate queen, we can also constrain the ending row. If we have three queens remaining, then we can’t put </span><span>one of them</span><span> any </span><span>lower </span><span>than the third-to-last row (it can’t go in the second-to-last row, because then where would the subsequent queens be placed? Again, every successive queen must move forward to a next row). </span></p><p><span>&#xa0;</span></p><p><span>Here’s the code. Can it really make a difference? </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function queens9(</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">, x, y, results, queensSoFar) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var candidates = next</span><span class="CodeSnippet" style="font-family:Times, serif">ChessSquares3(queensSoFar, x, y </span><span class="CodeSnippet" style="font-family:Times, serif">–</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft </span><span class="CodeSnippet" style="font-family:Times, serif">+1);</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var candNum = 0; candNum &lt; candidates.length; candNum++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.push(candidates[candNum]);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queens9(</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif"> - 1, x, y, results, queensSoFar);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.pop();</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">else {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var result = [];</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx = 0; idx &lt; queensSoFar.length; idx++) { </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">result[idx] = queensSoFar[idx]; </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">results.push(result);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p><span>Let’s see if this helps. At this point, unless it makes the code really confusing we want the improvement – we will take all the performance and scale-up wins we can get.</span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p><span>Are you kidding? This optimization’s </span><span style="font-style:italic; text-decoration:underline">huge</span><span>: 0.67ms for 8x8, 2.26ms for 9x9, 10.5ms for 10x10, 45.3ms for 11x11. How about larger? 254ms for 12x12, 1434ms for 13x13 and 8838ms for 14x14. Nice! </span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p><span>15x15 takes a very long time, then crashes. Why? Our code now generates </span><span style="font-style:italic">lots</span><span> of data, quickly. We don’t waste time looking at unfruitful squares. We are hitting memory limits. Let’s address that. It may make our code less readable, but if you made it this far, you deserve the end of the story! </span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span>Let’s compress our location data: that huge array of final results and </span><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar</span><span> fragments. Even a small fix might get us to 15x15. Let’s bit-encode the X and Y coordinates into </span><span>a</span><span> number (not </span><span>an </span><span>array). We’ll encode/decode when we write/read them (</span><span class="CodeSnippet" style="font-family:Times, serif">readability--</span><span>, but performance might be worth it):</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function nextChessSquares4(queenArr, x, y) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var safeSquares = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var row = (queenArr.length) ? ((qu</span><span class="CodeSnippet" style="font-family:Times, serif">eenArr[queenArr.length-1] &gt;&gt;8) +</span><span class="CodeSnippet" style="font-family:Times, serif">1) :</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for ( ; row &lt; y; row++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; x; col++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var qNum = 0; qNum &lt; queenArr.length; qNum++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var qY = queenArr[qNum] &gt;&gt; 8;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var qX = queenArr[qNum] &amp; 0x0ff;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (qX == col ||</span><span class="CodeSnippet" style="font-family:Times, serif"> qX-qY == col-</span><span class="CodeSnippet" style="font-family:Times, serif">row ||</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">qX+qY == col+</span><span class="CodeSnippet" style="font-family:Times, serif">row)</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">{ break; }</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (qNum == queenArr.length) { safeSquares.push((row &lt;&lt; 8) + col); }</span></p><p style="line-height:115%; margin-left:18pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return safeSquares;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function queens10(</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">, x, y, results, queensSoFar) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var candidates = next</span><span class="CodeSnippet" style="font-family:Times, serif">ChessSquares4(queensSoFar, x, y </span><span class="CodeSnippet" style="font-family:Times, serif">–</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft </span><span class="CodeSnippet" style="font-family:Times, serif">+1);</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var candNum = 0; candNum &lt; candidates.length; candNum++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.push(candidates[candNum]);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queens10(</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif"> - 1, x, y, results, queensSoFar);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.pop();</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">else {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var result = [];</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx = 0; idx &lt; queensSoFar.length; idx++)</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{ result[idx] = queensSoFar[idx]; }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">results.push(result);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p><span>This optimization is nice as well: 20-30%! Also, as expected it reduces our memory usage (that’s why it runs faster), allowing us to reach 15x15, in 41 seconds! Congratulations. Here are timings: 0.53ms for 8x8, 1.35ms for 9x9, 6.62ms for 10x10, 32.5ms for 11x11, 169ms for 12x12, 1019ms for 13x13, 6320ms for 14x14, and 41329ms for 15x15. Yes, at 16x16 we crash, but this is still a huge success. </span></p><p><span>&#xa0;</span></p><p><span>We have one last trick up our sleeve. Has it already occurred to you? Every arrangement can be mirrored from left-to-right. So, how about if we try only the first-queen possibilities of the </span><span style="font-style:italic; text-decoration:underline">left</span><span> side, and then just “reflect” (quick copy) all the complete results to the other side as well! Basically, this just means we take a complete result and reflect the X coordinate across the board’s midline. On an 8x8 board, column 0 would become column 7. Column 4 would become 3. Look at the code for more. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function nextChessSquares5(queenArr, x, y) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var safeSquares = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var row =(queenArr.length) ? ((q</span><span class="CodeSnippet" style="font-family:Times, serif">ueenArr[queenArr.length - 1] &gt;&gt;</span><span class="CodeSnippet" style="font-family:Times, serif">8) +1) :0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for ( ; row &lt; y; row++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var highestCol = (row == 0) ? x/2 : x;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var col = 0; col &lt; highestCol; col++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var qNum = 0; qNum &lt; queenArr.length; qNum++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var qY = queenArr[qNum] &gt;&gt; 8;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">var qX = queenArr[qNum] &amp; 0x0ff;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (qX == col || qX - qY == col - row || qX + qY == col + row)</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">{ break; }</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (qNum == queenArr.length) { safeSquares.push((row &lt;&lt; 8) + col); }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return safeSquares;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%"><span>This is one side of it. Let’s also look at the </span><span class="CodeSnippet" style="font-family:Times, serif">queens11</span><span> function that consumes it. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">N Queens (Series) – continued</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function queens11(</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">, x, y, results, queensSoFar) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var candidates = nextChessSquares5(queensSoFar,x,y-</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif">+1);</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var candNum = 0; candNum &lt; candidates.length; candNum++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.push(candidates[candNum]);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queens11(</span><span class="CodeSnippet" style="font-family:Times, serif">nQueensLeft</span><span class="CodeSnippet" style="font-family:Times, serif"> - 1, x, y, results, queensSoFar);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">queensSoFar.pop();</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">else {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var result = [];</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var result2 = [];</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var idx = 0; idx</span><span class="CodeSnippet" style="font-family:Times, serif"> &lt; queensSoFar.length; idx++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">result[idx] = queensSoFar[idx];</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var xCoord = queensSoFar[idx] &amp; 0x0ff;</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">xCoord = (x - 1 - xCoord);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">result2[idx] = queensSoFar[idx] &amp; (~0x0ff) | xCoord; </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">results.push(result);</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (queensSoFar[0] &lt; (x - 1)/2) { results.push(result2); }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p><span>Bottom line: this halves our runtime </span><span style="font-style:italic">yet a</span><span style="font-style:italic">gain</span><span>. We’ve successfully taken initial measurements down by 1500x or more. Here are final timings: 0.214ms for 8x8, 0.83ms for 9x9, 3.44ms for 10x10, 20.2ms for 11x11, 93.5ms for 12x12, 582ms for 13x13, 3283ms for 14x14, and 23459ms for 15x15.</span></p><p><span>&#xa0;</span></p><p><span>There you have it, a play-by-play performance journey that took initially dysfunctional code and, after fixing it, improved performance by (depending on the size of the board) a factor of 20,000x. Not bad! </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>