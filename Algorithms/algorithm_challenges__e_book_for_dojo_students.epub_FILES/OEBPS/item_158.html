<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_89"><span>Sorting Review</span></h2><p class="Normal1"><span>We discussed numerous aspects that different parties might consider important in judging a piece of software </span><span>“</span><span>good</span><span>”</span><span>.</span><span> </span><span>These include correctness, resiliency to bad inputs, security against hackers, being easy and fun to use, extensibility to accommodate future features, clarity of being understood by other engineers, whether the software is easily internationalized to 100+ spoken languages around the world, how easily it can be deployed or updated, etc.</span><span> </span><span>Depending on your role, </span><span>“</span><span>good</span><span>”</span><span> software means different things.</span><span> </span><span>For most, though, performance is in your top 3 most important factors.</span><span> </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>We focus on performance of </span><span style="font-style:italic">sorting algorithms</span><span> because there are multiple diverse ways to sort data, and most algorithms have at least one redeeming factor making it valuable in some situation.</span><span> </span><span>We need to know when to choose that particular algorithm, based on the </span><span>problem’s </span><span>requirements</span><span>.</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span>For</span><span> algorithm performance</span><span>, w</span><span>e factor out hardware</span><span> specifics and programming language</span><span>, only comparing </span><span>an algorithm</span><span> to itself, </span><span>with some other larger input data.</span><span> </span><span>The head start from having a faster programming language is insignificant compared to the power of a superior algorithm (if our data set is big enough).</span><span> </span><span>As our input data grow larger by N, by what factor does runtime grow?</span><span> </span><span>By what factor does memory requirement grow?</span><span> </span><span>This type of analysis is called Big-O notation.</span><span> </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span>We focused primarily on the Big-O of an algorithm</span><span>’</span><span>s </span><span style="font-style:italic">runtime</span><span> (how long </span><span>it takes</span><span> to run), but also memory usage.</span><span> </span><span>Runtime complexity is often understood by looking at nesting of loops.</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">O(N</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.67em; vertical-align:super">2</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> algorithm</span><span>s such as b</span><span>ubble</span><span> s</span><span>ort </span><span>are</span><span> considered slow.</span><span> </span><span>The basic algorithms used to teach sorting are all </span><span class="CodeSnippet" style="font-family:Times, serif">O(N</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.67em; vertical-align:super">2</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> because, essentially, they compare every value to every other value (N x almost-N).</span><span> </span><span>However, some algorithms have optimizations that lead to significant differences between average run-time and best-case runtime.</span><span> </span><span>More sophisticated algorithms use </span><span>“</span><span>divide and conquer</span><span>”</span><span> schemes that quickly cut the problem space so that each value is </span><span>not</span><span> compared against every other.</span><span> In this </span><span>way,</span><span> they roundly defeat </span><span class="CodeSnippet" style="font-family:Times, serif">O(N</span><span class="CodeSnippet" style="font-family:Times, serif; font-size:0.67em; vertical-align:super">2</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> algorithms </span><span>–</span><span> thei</span><span>r average performance is </span><span class="CodeSnippet" style="font-family:Times, serif">O(N</span><span class="CodeSnippet" style="font-family:Times, serif">logN)</span><span>.</span><span> </span><span>That said, they might have weaknesses</span><span>,</span><span> such as specific input data that trigger horribl</span><span>e worst-case performance (quick s</span><span>ort).</span><span> </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span>We discussed specific characteristics of sorting algorithms, and when they might be important.</span><span> </span><span>These include being </span><span style="font-style:italic; font-weight:bold">adaptive</span><span> (taking advantage of partially sorted data), </span><span style="font-style:italic; font-weight:bold">stable</span><span> (retaining existing sequence of duplicates), </span><span style="font-style:italic; font-weight:bold">in-place</span><span> (not </span><span>using</span><span> </span><span>space</span><span> beyond the input data).</span><span> </span><span>None of the </span><span class="CodeSnippet" style="font-family:Times, serif">O(N</span><span class="CodeSnippet" style="font-family:Times, serif">log</span><span class="CodeSnippet" style="font-family:Times, serif">N</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> algorit</span><span>hms are adaptive, and although merge s</span><span>ort is the only one that is stable, it is also the only one </span><span style="font-style:italic">not </span><span>in-place.</span><span> </span><span>Memory usage might be </span><span style="font-style:italic">heap</span><span> (</span><span>from </span><span>copying </span><span>input data</span><span>)</span><span>, or </span><span style="font-style:italic">stack</span><span> (</span><span>from recursive </span><span>“</span><span>divide and conquer</span><span>”</span><span> calls</span><span>)</span><span>.</span><span> O</span><span>n mobile devices memory is often scarce</span><span>; o</span><span>perating in-place is usually critical. </span></p><p class="Normal1" style="line-height:115%"><br /><span>I</span><span>n special </span><span>situations,</span><span> you can use unusual sorting algorithm</span><span>s</span><span> such as CountingSort</span><span> or Radix, which miraculously sort simple values in </span><span class="CodeSnippet" style="font-family:Times, serif">O(</span><span class="CodeSnippet" style="font-family:Times, serif">N</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> but cannot accommodate additional data</span><span>.</span><span> </span><span>Understanding the various characteristics of these algorithms is what enables you to </span><span>choose</span><span> the right tool for the right job.</span></p><p class="Normal1"><br style="page-break-before:always; clear:both" /></p></div></body></html>