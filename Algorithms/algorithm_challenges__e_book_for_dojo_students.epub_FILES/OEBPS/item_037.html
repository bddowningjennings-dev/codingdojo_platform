<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_139"><span>Code Tuning</span></h2><p><span>You’ve chosen a good design; your algorithm choice is sound; you are keeping all the different pipes (network, storage, memory, CPU, power) fully-utilized and at approximately equal levels; you’ve applied all the appropriate compiler optimization and server configuration settings; somehow it isn’t enough to give your software the performance it needs. What now? </span></p><p><span>&#xa0;</span></p><p><span>Code tuning is becoming a bit of a lost art, except in larger products where all the obvious levers have already been pulled. In the old days, grey-bearded gurus would hand-code assembly-language inner-loop routines because compilers were not yet as good as a human could be. This is no longer the case, but you can still make a major difference in performance with some important choices in how you code something. Pay attention to what functions you use and how much data you have. Is your data space growing fast? Large-but-relatively-unchanging is better than almost-as-large-but-highly-variable. In these cases, rewriting a chunk of code might make a noticeable difference. When data sets get large, the software maxim of “smaller is faster” really sets in. In these cases, you need to pay special attention to your data structure choice. Algorithms </span><span>(“work smarter”) </span><span>can save CPU and battery, </span><span>whereas</span><span> data structures </span><span>(“work smaller”) help with </span><span>everything else: RAM, storage, network, etc. When you are running out of RAM, </span><span>you’ll do </span><span>almost </span><span>anything </span><span>to generate more (or consume less!). Stay tuned….</span></p><p><span>&#xa0;</span></p><p><span>Th</span><span>e</span><span> next journey is largely algorithmic</span><span>,</span><span> based on a question</span><span> from the earliest</span><span> chapters. Have fun</span><span>! </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Is Number Prime (Series)</span></p><p><span>Given number, return whether it is prime. Prime</span><span> number</span><span>s are only evenly divisible by themselves and 1. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Before moving on, </span><span>quickly </span><span>write a naïve </span><span class="CodeSnippet" style="font-family:Times, serif">isNumberPrime</span><span>, </span><span>and </span><span style="font-style:italic">then</span><span> optimize</span><span> it</span><span>.</span></p><p><span>&#xa0;</span></p><p><span>OK, hopefully you’ve spent good quality time with pencil, paper, marker, whiteboard. From our side, here is a naïve implementation we came up with on very short order. No guarantees! </span></p><p><span>&#xa0;</span></p><p><span>What do you see? Is it a starting point?</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Counting Primes</span></p><p style="line-height:115%"><span>Build on </span><span>the</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">isNumberPrime(num)</span><span> function </span><span>at left to </span><span>count the primes </span><span>that are </span><span>equal or less than given integer. </span></p><p><span style="font-weight:bold">&#xa0;</span></p><p style="line-height:115%"><span style="font-weight:bold">Second:</span><span> add the </span><span>ability to profile this function, measuring progress as we optimize </span><span class="CodeSnippet" style="font-family:Times, serif">isNumberPrime</span><span>.</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime(num) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for(var </span><span class="CodeSnippet" style="font-family:Times, serif">count=1; count&lt;=</span><span class="CodeSnippet" style="font-family:Times, serif">num;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">count++)</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (nu</span><span class="CodeSnippet" style="font-family:Times, serif">m/count == parseInt(num/count))</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif; font-weight:normal"> </span><span class="CodeSnippet" style="font-family:Times, serif">return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p style="line-height:115%"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p><span>For the record: n</span><span>o, </span><span>the previous</span><span> source is a </span><span style="font-style:italic">piece</span><span>, but not</span><span> a </span><span style="font-style:italic">piece of code</span><span>. </span><span>I</span><span>t doesn’t work; it considers </span><span style="font-style:italic">nothing </span><span>prime (some people are just impossible to please). Fixing </span><span>it, now we have the following. This s</span><span>hould be </span><span>much</span><span> better, but again, no guarantees! </span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime0(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif">                        </span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">                     </span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">// start at 2 not 1</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var count = 2; count &lt; num; count++) {</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">// &lt; num, not &lt;= num </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num / co</span><span class="CodeSnippet" style="font-family:Times, serif">unt == parseInt(num / count)) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return false;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%"><span>Hopefully </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime0</span><span> will work as a starting point</span><span>.</span><span> Also, below is </span><span>some</span><span> code to </span><span>quantify</span><span> our improvements. Using</span><span> a function pointer </span><span>enables me to </span><span>quickly measure new routines.</span></p><p style="font-size:0.73em; line-height:115%"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function countPrimesUpTo(limit, primeFn)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var count = 0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var start = performance.now();</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var num = 0; num &lt;= limit; num++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (primeFn(num)) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">count++;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var end = performance.now();</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">"The function " + primeFn.name + "()"</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">+</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">" found " + count + " primes"</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">+</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">" in " + (end - start) + " msec.";</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet">&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">countPrimesUpTo(1000000,isPrime0);</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">// Here’s how we’ll use the profiler.</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span>What do you think about this implementation? How similar is it to yours? What might you expect the run-time performance to be, if we counted primes up to </span><span style="font-style:italic; font-weight:bold">1 million</span><span>? Because the larger the number, the greater number of possible divisors we must check, the complexity of this function as </span><span class="CodeSnippet" style="font-family:Times, serif">num</span><span> grows is </span><span style="font-style:italic; font-weight:bold">O(n</span><span style="font-size:0.67em; font-style:italic; font-weight:bold; vertical-align:super">2</span><span style="font-style:italic; font-weight:bold">)</span><span>. The fact that we </span><span style="font-style:italic">count</span><span> all of them compounds the problem, so we should expect</span><span> </span><span style="font-style:italic; font-weight:bold">O(n3)</span><span> behavior. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>On this machine, </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime0</span><span> returned that there are 78500 primes under 1 Million, and it did so in 501.5 seconds. That will be our baseline. Do you note anything about </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime0</span><span>? Does it do all that it should? Specifically, </span><span style="font-style:italic">where’s the bug</span><span>? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p style="line-height:115%"><span>The </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime0</span><span> </span><span>function is fine – unless you expect it to return </span><span style="font-style:italic">correct</span><span> answers for </span><span style="font-style:italic">all inputs</span><span>. (-: </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Specifically, now we are considering </span><span style="font-style:italic">too many</span><span> numbers to be prime. (That kind of degrades the whole </span><span style="font-style:italic">prime</span><span> label, if you get what I mean. We need that club to be more exclusive.) Negative numbers cannot be prime. Fractional numbers are not prime. Also, the numbers 0 and 1 are by definition not prime. So, as it turns out, we cannot consider </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime0</span><span> our baseline; we are still on the hunt for a function that returns </span><span style="text-decoration:underline">correct outputs</span><span>. Let’s fix it and see how far we get. Here’s </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime1</span><span> (of many, to be sure):</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Fixes bugs: num = 1, 0, negatives, non-integers</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime1(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 2 || num != parseInt(num)) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var count = 2; count &lt; num; count++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num / count == parseInt(num / count)) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return false;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Unlike </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime0</span><span>, this one is correct. Non-integers, or </span><span>anything </span><span>below 2 </span><span>is </span><span>considered non-prime. Counting primes to 1 Million, it returned </span><span>78498 primes (correct!)</span><span> in 476.3 seconds. We have </span><span>a</span><span> baseline</span><span>!</span><span> </span><span>Sadly, for our </span><img src="item_135.png" width="30" height="18" alt="" /><span> behavior, counting primes to </span><span style="font-style:italic">100</span><span> Million would take 100*100*100 longer: </span><span style="font-weight:bold">15 yrs</span><span>.</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>How can we make it faster? It is </span><span>already </span><span>fairly basic</span><span>; it only calls</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">parseInt</span><span> – </span><span>actually a good target. </span><span class="CodeSnippet" style="font-family:Times, serif">ParseInt</span><span> exists to convert </span><span>various</span><span> inputs to integers – floats but also strings</span><span> or</span><span> even arrays. If </span><span>expect </span><span>only floats, we can use a less expensive function. </span><span>Instead of </span><span class="CodeSnippet" style="font-family:Times, serif">parseInt</span><span>, </span><span>let’s try using </span><span class="CodeSnippet" style="font-family:Times, serif">Math.floor</span><span>. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Uses Math.floor() instead of parseInt().</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime2(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 2 || num != Math.floor(num)) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var count = 2; count &lt; num; count++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num / count == Math.floor(num / count)) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return false;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p><span>Before we go further, it is important to set our </span><span style="font-style:italic">performance goals</span><span>. Don’t go optimizing unless you have some sort of goal in mind. Here it is: 1) we want to count the primes up to </span><span style="font-style:italic; text-decoration:underline">100 Million, in 60 seconds</span><span>; 2) we also want to </span><span>be able to </span><span>count primes up to </span><span style="font-style:italic; text-decoration:underline">1 Billion</span><span> but we’re not sure how long that should take. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>So how did </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime2</span><span> fare when measured? A lot better than </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime1</span><span>! Specifically counting primes to 1 Million took 147.7 seconds, which is an improvement of more than 3</span><span>x over previous baseline. Nice! </span><span>Now what? Would it be possible to eliminate the function call altogether? What do you recommend? </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>As it turns out, there is an even less expensive way to check whether something is an integer. Do you remember the modulus operator </span><span style="font-weight:bold">%</span><span>? Consider what </span><span class="CodeSnippet" style="font-family:Times, serif">num</span><span> might be after executing </span><span class="CodeSnippet" style="font-family:Times, serif">num = num % 1</span><span>. Basically, it returns the less-than-one fractional component of the number. </span><span>Certainly,</span><span> any primitive operator (such as </span><span class="CodeSnippet" style="font-family:Times, serif">+ - * / % &amp; | ^ ~</span><span>) will be much faster than any function call. </span></p><p><span>&#xa0;</span></p><p><span>Let’s make this quick change and measure the improvement. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Uses % instead of Math.floor().</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime3(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 2 || num % 1) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var count = 2; count &lt; num; count++) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % count == 0) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return false;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>What improvement do you expect? In a way, it depends on how bad you think </span><span class="CodeSnippet" style="font-family:Times, serif">Math.floor</span><span> is…. The function </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime3</span><span> completes counting 1 million primes in 111.1 seconds. That’s a nice 25% cut. As before, you will see plenty of variability in your own measurements, and a good practice is to create as stable and reproducible an environment as you can, make 5 or 7 measurements, throw out the best and worst measurements, and average the rest. This is what I did for this chapter’s measurements. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>That seems like as much as we can squeeze out of the actual math operation. What else is there? Well, let’s think through all the values of </span><span class="CodeSnippet" style="font-family:Times, serif">count</span><span> that we are dividing against </span><span class="CodeSnippet" style="font-family:Times, serif">num</span><span>. The values are 2, 3, 4, 5, 6, … wait a minute! 4 and 6 aren’t going to matter. The value 2 is the only </span><span style="font-style:italic">even</span><span> one we really care about. We can eliminate all the rest of the even numbers from our </span><span class="CodeSnippet" style="font-family:Times, serif">FOR</span><span> loop! We should expect this to cut our run-time </span><span>basically </span><span>in half. On the next page is the updated code, and following that we mention how it impacted the performance. What do you expect? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p><span>Here is updated code. Note how we immediately exit on special cases – the very definition of </span><span style="font-style:italic">fail-fast</span><span>. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Only check odd factors (after checking 2).</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime4(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % 2 == 0</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">&amp;&amp; num &gt; 2) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 2</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">|| num % 1) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var count = 3; count &lt; num; count += 2) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % count == 0) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return false;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>The </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime4</span><span> function counts 1 Million primes in 60.7 seconds: not quite a 2x speedup, but close. So far we have a 7.5x acceleration</span><span> from our </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime1</span><span> baseline of </span><span>476 seconds</span><span>. </span><span>This is good, but w</span><span>hat else can we do to reduce the number of unnecessary divisors? </span></p><p><span>&#xa0;</span></p><p><span>Think about various </span><span style="font-style:italic">prime</span><span> factors of a compound number. How large could </span><span>these prime factors</span><span> be? Prime factors, </span><span>when </span><span>multiplied by other prime factors, equal </span><span>a compound </span><span>number. A number like 36 has (multiple) prime factors of 2 and 3. We would immediately discover this number is not prime, upon checking 2, but that doesn’t help us understand how far toward a number we need to check divisors, before having confidence that the number </span><span>is</span><span> prime (what if </span><span>our</span><span> 36 </span><span>were </span><span>37 instead?). Perhaps </span><span>we need to check factors up to </span><span>a specific fraction of the given number? </span></p><p><span>&#xa0;</span></p><p><span>Maybe a different example</span><span>. To </span><span>think more clearly about this </span><span>first-prime-to-number ratio, let’s pick a number with only two prime factors. How about 65 – prime factors are 5 and 13. When we get to the 5, we again have discovered that it is not prime. A little better, but again we haven’t learned anything – it’s not </span><span>as if </span><span>we will </span><span>always </span><span>hit all the primes for a number once we get to 10% of the number. There are numbers smaller than 65 that have first-primes bigger than 5, it seems. What are they? </span><span>Well, if we want the first-prime to be larger, then we need the second-prime to be smaller. </span><span>How about </span><span>trying numbers</span><span> with </span><span>prime </span><span>factors </span><span style="font-style:italic">really close together</span><span> – a </span><span style="text-decoration:underline">square</span><span>: 49. Squares give us first-prime factors that are as far from zero as possible</span><span> (if they were any bigger, they would exceed the second-prime)</span><span>. </span></p><p><span>&#xa0;</span></p><p><span>This guides our next </span><span>optimization! Just as we try only odd divisors (after trying 2), we also need to try divisors </span><span style="font-style:italic">only as </span><span style="font-style:italic">high </span><span style="font-style:italic">as</span><span style="font-style:italic"> the number’s square root</span><span>. For 97, we need not try prime factors higher than </span><span style="font-weight:bold">9</span><span>. </span></p><p><span>&#xa0;</span></p><p><span>But will this make </span><span>a real difference in performance? What would a good implementation be? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p style="line-height:115%"><span>Here’s an implementation of </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime5</span><span> that tries divisors up to the number’s square-root. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Only check factors up to sqrt(num).</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime5(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % 2 == 0</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">&amp;&amp; num &gt; 2) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 2</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">|| num % 1) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var count = 3; count &lt;= Math.sqrt(num); count += 2) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % count == 0) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>How is performance? </span><span>F</span><span>abulous</span><span>! To </span><span>count primes under 1 million, </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime5</span><span> </span><span>uses 130.4 millisec</span><span>s (ms)! Compared to </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime4</span><span>, it’s a 500x speedup for that benchmark. Also, it means we can count higher. How about 50 million instead of 1 million? This successfully runs and completes in 30.7 seconds. </span></p><p><span>&#xa0;</span></p><p><span>Gee, how do we get much better than that? Maybe we don’t. Something important to note here is that you should always </span><span style="font-style:italic">have reasonable performance goals in mind before you start optimizations</span><span>. Then stop optimizing when you reach them. Without these goals, how will you ever know when you </span><span style="font-style:italic">should be done</span><span> with it? (I realize some of you may feel I </span><span style="font-style:italic">should be done</span><span> with this journey, but I’ll continue.) </span></p><p><span>&#xa0;</span></p><p><span>If, like us, you are a purist and want to profile your code using single-pass measurements with just a single large value, we can help. Here is a set of progressively larger prime numbers, as well as a set of roughly correlated compound numbers that require significant calculation to prove </span><span>as </span><span>non-prime: </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">var bigPrimes </span><span class="CodeSnippet" style="font-family:Times, serif">=</span><span class="CodeSnippet" style="font-family:Times, serif"> [</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">       </span><span class="CodeSnippet" style="font-family:Times, serif">99991,</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">      </span><span class="CodeSnippet" style="font-family:Times, serif">999983,</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">      </span><span class="CodeSnippet" style="font-family:Times, serif">9999991,</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">99999989,</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span class="CodeSnippet" style="font-family:Times, serif">999999937,</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span class="CodeSnippet" style="font-family:Times, serif">9999999967,</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">99999999977,</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">999999999989,</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">9999999999971,</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">99999999999973,</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">999999999999989,</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">9007199254740881</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">];</span></p><p style="line-height:115%"><span class="CodeSnippet">&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">var bigCompounds = [</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">       </span><span class="CodeSnippet" style="font-family:Times, serif">99221,</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">       </span><span class="CodeSnippet" style="font-family:Times, serif">995779,</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">       </span><span class="CodeSnippet" style="font-family:Times, serif">9922331,</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">99799811,</span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">999634589,</span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">9999399973,</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">99999515333,</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span class="CodeSnippet" style="font-family:Times, serif">999966000289,</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span class="CodeSnippet" style="font-family:Times, serif">9999919930081,</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">99999919999487,</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">999998950017311,</span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">9007197807561043</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">];</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>What is our next step? </span><span>Maybe we can unroll our inner loop a little, to skip a few more obvious values – not unlike what we are doing when we </span><span class="CodeSnippet" style="font-family:Times, serif">count += 2</span><span> each time (skipping the even values). Could we do that for mu</span><span>ltiples of three as well? Maybe</span><span>, but would that make a noticeable difference? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21 – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p style="line-height:115%"><span>Turns out it does help, considerably. Compared to </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime5</span><span>, our new function </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime5a</span><span> executes in about 2/3 the time. From the changes we made to our inner loop, this makes sense. </span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime5a(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (nu</span><span class="CodeSnippet" style="font-family:Times, serif">m % 2 == 0</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">&amp;&amp; num &gt; 2) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % 3 == 0</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">&amp;&amp; num &gt; 3) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 2</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">  </span><span class="CodeSnippet" style="font-family:Times, serif">|| num % 1) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var count = 5; count &lt;= Math.sqrt(num); count += 4) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % count == 0) { return false; }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">count += 2;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % count == 0) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p><span>So now we are counting primes to 1 million in about 84.1 millisecs, and to 100 Million in about 46 secs. This is great – </span><span>we are </span><span>passing our first performance goal! </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>S</span><span>ide note</span><span>:</span><span> a single run </span><span>of </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime5a</span><span class="CodeSnippet" style="font-family:Times, serif">(</span><span class="CodeSnippet" style="font-family:Times, serif">9007199254740881</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> – our</span><span> biggest prime </span><span>– completes in</span><span> </span><span style="text-decoration:underline">270ms</span><span>. Our baseline </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime1</span><span> scales linearly, needing</span><span> 2.5 minutes </span><span>for </span><span class="CodeSnippet" style="font-family:Times, serif">9999999967</span><span> (</span><span>1,000,000</span><span>x faster</span><span>). We can extrapolate what </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime1</span><span> </span><span>need</span><span>s</span><span> for </span><span class="CodeSnippet" style="font-family:Times, serif">9007199254740881</span><span>: a whopping </span><span style="font-style:italic; text-decoration:underline">4.4 years</span><span>! </span></p><p><span>&#xa0;</span></p><p><span>Let’s say that the business team identified an exciting new opportunity for our product if we can optimize it </span><span>even </span><span>more than before. Our performance goals are now </span><span style="text-decoration:underline">threefold</span><span>: </span></p><p class="ListParagraph" style="margin-bottom:0pt; margin-left:36pt; text-indent:-18pt"><span>1)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>C</span><span>ount primes to 100 Million in 60 seconds, </span><span style="font-style:italic">first time</span><span> (with ‘cold cache’), </span></p><p class="ListParagraph" style="margin-bottom:0pt; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span>2)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>C</span><span>ount primes to 1 Billion on standard lap</span><span>top without crashing, and</span></p><p class="ListParagraph" style="margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span>3)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>(new) </span><span>C</span><span>ount primes to 100 Million in </span><span style="font-style:italic">1 second thereafter</span><span> (with ‘warm cache’). </span></p><p><span>These are very aggressive goals – remember when we were counting primes to </span><span style="font-weight:bold; text-decoration:underline">1</span><span> Million in 476 secs? </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Our </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime5a</span><span> function has been good to us so far. Let’s set it loose </span><span>counting primes </span><span>toward 1 Billion, shall we? Good news: after 17 minutes or so, it eventually gets to 1 Billion without error. </span><span>So,</span><span> we’ve </span><span style="font-weight:bold">met our new performance goal #2</span><span> as well! </span></p><p><span>&#xa0;</span></p><p><span>Goal #3 is going to be tough. What is a reasonable step toward that goal? We already calculate primes quickly; the only way faster </span><span>would be to </span><span style="font-style:italic">not</span><span> calculate</span><span> </span><span>at all … a</span><span>h! Perhaps we won’t calculate: we’ll </span><span style="font-style:italic">remember</span><span> them. Yes, a caching strategy. Just as </span><span>we did </span><span>earlier with Fancy Fibonacci, let’s save previous results when asked if a number is prime. </span></p><p><span>&#xa0;</span></p><p><span>The next page should have a reasonable implementation of our caching scheme, but before you turn to it, </span><span style="font-style:italic">create </span><span style="font-style:italic">this</span><span style="font-style:italic"> yourself</span><span>. It’s for your own good, you know.</span><span> </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p style="line-height:115%"><span>We are now up to </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime6</span><span> – and if this one doesn’t speed things up, then we don’t know what will. What are the issues, if any, with this implementation</span><span>? </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Cache previous results.</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">var prevResults = [false, false, true];</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime6(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 0 || num % 1) { return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (prevResults[num] === undefined) { </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % 2 == 0) { prevResults[num] = false; }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">else {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var count = 3; count &lt;= Math.sqrt(num); count += 2) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % count == 0) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">prevResults[num] = false;</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">break;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (count &gt; Math.sqrt(num)) { prevResults[num] = true; }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return prevResults[num]; </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Looks like this version will be a real memory hog, that’s the main issue. As a result, though, it should work really well for subsequent requests. In </span><span>fact,</span><span> this is exactly the case. It counts primes under 1 Million in 0.189 seconds! Furthermore, it counts primes to 100 million with cold cache in less than 90 seconds, and second time in just 0.653 seconds! </span><span>So,</span><span> we have now </span><span style="font-weight:bold">met performance goal #3</span><span>. We still need to get the “cold cache” version down to 60 second for 100 Million. While we’re here let’s see whether </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime6</span><span> can scale to 1 Billion.</span></p><p><span>&#xa0;</span></p><p><span>Unfortunately, we don’t get there. At something like 117 million, we run out of memory and crash (with the “Aw, Snap!” screen in Chrome, for example). Ugh. Why is this, and what do we do now? </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p><span>Let’s continue going after goal #1 before starting in on the scalability goal (#2). How else can we make this process faster? How about an extension of our (don’t check evens) idea? What if we </span><span style="font-style:italic">only</span><span> check prime numbers as the factors: only check whether the number is divisible by 2, 3, 5, 7, 11, 13, etc. As the numbers get larger, this should save a lot of time. How would you know whether a number is prime, without calling yourself to find out, though? (-: I think we would specifically cache an array of only the primes, so we can oh-so-quickly breeze through them to check whether to add to our prime list. This won’t necessarily scale any higher, but it should be a good bit faster! Let’s code it first, then measure it. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Only check PRIME factors (up to sqrt). Cache primes for this.</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Try cache first, before checking for negative / fractional.</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">var prevResults = [false, false, true];</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">var primes = [2];</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime7(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (prevResults[num] === undefined) { </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 0 || num % 1) { return false; }</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">while (prevResults.length &lt;= num) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var next = prevResults.length;</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var rootNext = Math.sqrt(next);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var primeIdx = 0; primes[primeIdx] &lt;= rootNext; primeIdx++) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">if (next % primes[primeIdx] == 0) {</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">prevResults.push(false);</span></p><p style="line-height:115%; margin-left:72pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">break;</span></p><p style="line-height:115%; margin-left:36pt; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:18pt; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (primes[primeIdx] &gt; rootNext) {</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">prevResults.push(true);</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">primes.push(next);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return prevResults[num]; </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>So how did </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime7</span><span> do? Did it meet our performance goals? Yes, it met some! First, we counted to 100 Million primes in only 33.91 sec, cold cache. With warm </span><span>cache,</span><span> we ran in 0.685 sec for subsequent 100 Million requests! </span><span>So,</span><span> we have goals #1 and #3 taken care of, nicely. We’ve really come far! </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>About goal #2… how far </span><span style="font-style:italic">can</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime7</span><span> count, anyway? Not a lot farther, as it turns out. It counts to 122 Million without problem (getting there in 40sec), but 123 Million causes an “Aw, Snap!” So there.</span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p><span>We’ve met our #1 and #3 performance goals. The only one remaining is scalability, so we must figure out how to jettison memory usage without sacrificing the big speed that we’ve won. Let’s assess. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Currently we are caching previous results – a boolean for every positive integer</span><span>. To </span><span>count to 1 Billion, we’ll need a Boolean for each of those. In JavaScript, a Boolean consumes 4 bytes, so if this algorithm did get all the way to 1 Billion, the </span><span class="CodeSnippet" style="font-family:Times, serif">prevResults</span><span> array would consume 4GB of memory – whoa. Also, what about the cached </span><span class="CodeSnippet" style="font-family:Times, serif">primes</span><span> array? At 100 Million, this is </span><span>an array of </span><span>5.76 Million elements. These are numbers, hence eight bytes, but at 46 MB it still looks pretty svelte</span><span> compared to </span><span class="CodeSnippet" style="font-family:Times, serif">prevResults</span><span>. What if we tossed the whole </span><span class="CodeSnippet" style="font-family:Times, serif">prevResults</span><span> array and </span><span>relied only on</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">primes[]</span><span>, working solo? Here’s the code: </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// Cache primes ONLY (not prevResults[]). Mem usage dramatically reduced. </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">var primes = [2];</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">var highestCheck = 2;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime8(num)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 2 || num % 1)</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">{ return false; </span><span class="CodeSnippet" style="font-family:Times, serif">     </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num % 2 == 0)</span><span class="CodeSnippet" style="font-family:Times, serif">    </span><span class="CodeSnippet" style="font-family:Times, serif">   </span><span class="CodeSnippet" style="font-family:Times, serif">{ return (num == 2); }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-weight:normal">&#xa0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var checkStart = Math.min(num, highestCheck) | 1;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var check = checkStart; check &lt;= num; check += 2) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var rootCheck = Math.sqrt(check);</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var primeIdx = 0; primes[primeIdx] &lt;= rootCheck; primeIdx++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (check % primes[primeIdx] == 0) { break; }</span></p><p style="line-height:115%; text-indent:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (primes[primeIdx] &gt; rootCheck) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (check &gt; highestCheck) { primes.push(check); }</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (check == num) { </span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">highestCheck = Math.max(highestCheck, num);</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">return true;</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">highestCheck = Math.max(highestCheck, num);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return false;</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p><span>&#xa0;</span></p><p><span>What do you think? Will we still see the gains we earned? Form a view, then join me on the next page. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p><p style="line-height:115%"><span>The </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime8</span><span> implementation is fascinating. It was able to count primes to 100 Million in about 50 seconds, first time</span><span> (</span><span style="font-style:italic">cold</span><span> scenario)</span><span>. However, as we might expect from removing</span><span> a direct-</span><span>result cache, the </span><span style="font-style:italic">warm</span><span> scenario did lose some of the </span><span>previous </span><span>gains. Specifically</span><span>,</span><span> a second-time count to 100 Million required about 25.6 sec, rather than about 700 ms with </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime7</span><span>. On the flip side</span><span>, it scales</span><span>. </span><span style="font-style:italic">It scales</span><span style="font-style:italic">!</span><span> It counted past 500 Million</span><span> (</span><span>i</span><span>t’</span><span>s still going as I type this</span><span>!). I’ll need to update this</span><span> </span><span>when it does </span><span>in fact cross 1 Billion, but I trust that this will certainly occur. </span><span>(Yep, it did.) </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>To win the warm scenario, we’ll</span><span> need to hold on to some flavor of our </span><span class="CodeSnippet" style="font-family:Times, serif">prevResults</span><span> array. </span><span>We also need to reduce our size</span><span> though, and th</span><span>e direct result cache</span><span> is </span><span>by far our </span><span>largest </span><span>size component</span><span>. This suggests that we go right at the big </span><span>memory </span><span>consumer and figure out even a small improvement. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>T</span><span>o</span><span> really squeeze space, we could convert </span><span>a </span><span>boolean array into</span><span> a</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">B</span><span class="CodeSnippet" style="font-family:Times, serif">itArray</span><span>. Here, we </span><span>put</span><span> 32 bits in</span><span>to</span><span> </span><span>the </span><span>space </span><span>usually </span><span>filled by 1 boolean</span><span>;</span><span> this would </span><span style="font-style:italic">dramatic</span><span style="font-style:italic">ally</span><span> reduce our cache’s size</span><span>. Let’s give it a try. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function B</span><span class="CodeSnippet" style="font-family:Times, serif">itArray(numBits)</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var arr = [];</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for (var i=0; i&lt;</span><span class="CodeSnippet" style="font-family:Times, serif">(numBits/32); i++)</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">arr[i] = 0;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">this.numBits = numBits;</span></p><p style="line-height:115%; text-indent:18pt"><br style="mso-column-break-before:always; clear:both" /><span class="CodeSnippet" style="font-family:Times, serif">this.read = function(bitIdx)</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if(bitIdx&lt;0 || bitIdx % 1 </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">|| bitIdx &gt;= this.numBits) </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">return;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var bitNum = bitIdx &amp; 0b11111;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var arrIdx = bitIdx &gt;&gt;&gt; 5;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">return(arr[arrIdx]&gt;&gt;bitNum) &amp;</span><span class="CodeSnippet" style="font-family:Times, serif">1;</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">this.set = function(bitIdx) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if(</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">bitIdx</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">&lt;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">0</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">||</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">bitIdx</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">%</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">1</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span class="CodeSnippet" style="font-family:Times, serif"> </span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">return;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (bitIdx &gt;= this.numBits) { </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var idx</span><span class="CodeSnippet" style="font-family:Times, serif">=(</span><span class="CodeSnippet" style="font-family:Times, serif">this.numBits+31)/32</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for(</span><span class="CodeSnippet" style="font-family:Times, serif">;</span><span class="CodeSnippet" style="font-family:Times, serif">idx&lt;</span><span class="CodeSnippet" style="font-family:Times, serif">(numBits/32);i</span><span class="CodeSnippet" style="font-family:Times, serif">d</span><span class="CodeSnippet" style="font-family:Times, serif">x++) </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">{ arr[idx] = 0; }</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">this.numBits = bitIdx + 1;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var bitNum = bitIdx &amp; 0b11111;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var arrIdx = bitIdx &gt;&gt;&gt; 5;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">arr[arrIdx] |= (1 &lt;&lt; bitNum);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><br style="mso-column-break-before:always; clear:both" /><span class="CodeSnippet" style="font-family:Times, serif">this.clear = function(bitIdx) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (bitIdx &lt; 0 || bitIdx % 1)</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">return;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (bitIdx &gt;= this.numBits) { </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var idx</span><span class="CodeSnippet" style="font-family:Times, serif">=</span><span class="CodeSnippet" style="font-family:Times, serif">(this.numBits+31)/32</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">for(;idx&lt;(numBits/32);</span><span class="CodeSnippet" style="font-family:Times, serif">idx++) </span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">arr[idx] = 0;</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">this.numBits = bitIdx + 1;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var bitNum = bitIdx &amp; 0b11111;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var arrIdx = bitIdx &gt;&gt;&gt; 5;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">arr[arrIdx] &amp;= ~(1 &lt;&lt; bitNum);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 21</span><span> – Optimization</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="font-size:1.27em; line-height:115%; margin-bottom:4pt"><span style="font-family:Times, serif"></span><span style="color:#000000; font-size:0.86em"> </span><span style="font-size:0.86em; font-weight:bold; text-decoration:underline">Is Number Prime (Series) – continued</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// prevResults to B</span><span class="CodeSnippet" style="font-family:Times, serif">itArray: 30x smaller </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">// than bool arr. Otherwise is isPrime7.</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">var primes = [2];</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">var baPrimes = new B</span><span class="CodeSnippet" style="font-family:Times, serif">itArray(3);</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">baPrimes.clear(0);</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">baPrimes.clear(1);</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">baPrimes.set(2);</span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">function isPrime9(num) {</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">var result = baPrimes.read(num);</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">(result</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">!==</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">undefined)</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">{</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">return result; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">if (num &lt; 0|| num % 1)</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">{ return false; }</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">while (num &gt;= baPrimes.numBits) {</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var next = baPrimes.numBits;</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">var rootNext = Math.sqrt(next);</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">for (</span><span class="CodeSnippet" style="font-family:Times, serif"> </span><span class="CodeSnippet" style="font-family:Times, serif">var primeIdx = 0;</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">primes[primeIdx] &lt;= rootNext; </span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">primeIdx++) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">i</span><span class="CodeSnippet" style="font-family:Times, serif">f (next%primes[primeIdx] ==0) </span><span class="CodeSnippet" style="font-family:Times, serif">{</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">baPrimes.clear(next);</span></p><p style="line-height:115%; margin-left:72pt"><span class="CodeSnippet" style="font-family:Times, serif">break;</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">if (primes[primeIdx] &gt; rootNext) {</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">primes.push(next);</span></p><p style="line-height:115%; margin-left:36pt; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">baPrimes.set(next);</span></p><p style="line-height:115%; margin-left:36pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%; text-indent:18pt"><span class="CodeSnippet" style="font-family:Times, serif">return baPrimes.read(num); </span></p><p style="line-height:115%"><span class="CodeSnippet" style="font-family:Times, serif">}</span></p><p style="line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span>There </span><span>simply </span><span>is n</span><span>o better way to </span><span>finish</span><span> </span><span>off </span><span>a performance journey than </span><span>with </span><span>a geeky bit-encoded data representation. Essentially, </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime9</span><span> performs as </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime7</span><span> does, but without an oversized memory footprint. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>The r</span><span>esults are fabulous. First, scalability: </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime9</span><span> runs </span><span>to</span><span> 1 Billion and keeps going! On my Mac, it </span><span>almost reaches</span><span> </span><span style="text-decoration:underline">2 Billion</span><span>: </span><span style="font-style:italic">much better</span><span> than </span><span>the requirement</span><span>. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>On th</span><span>e other goals, during our first-</span><span>time counting primes to 100 Million, </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime9</span><span> consumed about </span><span style="text-decoration:underline">30.5 sec</span><span>. </span><span>This is well ahead of our goal of 60 </span><span>secs</span><span> (and </span><span style="font-style:italic">destroys</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">isPrime1</span><span>’s expected </span><span style="text-decoration:underline">15 yrs</span><span>)</span><span>. Great! </span></p><p><span>&#xa0;</span></p><p><span>Even better, </span><span>the second-</span><span>time </span><span>count (“warm cache”), </span><span>ran in </span><span style="text-decoration:underline">0.964 sec</span><span>. </span><span>It feels </span><span>awesome to </span><span style="font-style:italic">barely</span><span> </span><span>meet </span><span>your performance goals, </span><span>as </span><span>you know you didn’t </span><span>add</span><span> unnecessary optimization (which can convolute code). </span></p><p><span>&#xa0;</span></p><p><span>What do you think about </span><span>our</span><span> </span><span>final </span><span>code? Is it </span><span>as</span><span> readable </span><span>as</span><span> the first version? </span><span>Might</span><span> an intern innocently </span><span>‘</span><span>fix</span><span>’</span><span> a bug and break </span><span>an</span><span> important feature by mistake? </span><span style="font-style:italic">Yes</span><span> – </span><span>that is a reasonable worry</span><span>. Like racehorses, high-performance code can be brittle. Always me</span><span>asure, </span><span>and watch</span><span> for regressions!</span><span> </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"></div></body></html>