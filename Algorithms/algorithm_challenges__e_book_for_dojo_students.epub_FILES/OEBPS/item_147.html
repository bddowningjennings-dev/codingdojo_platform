<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h1 id="navPoint_109"><img src="item_067.png" width="216" height="65" alt="" style="float:left; margin:0pt 9pt" /><span>Chapter 17</span><span> – Graphs</span></h1><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>One reason Amazon is an amazing company is because it can, overnight, deliver (almost) anything, from anywhere, to anywhere. How is that possible at </span><span style="font-style:italic">any</span><span> price, let alone a reasonable one? Amazon has made huge investments in </span><span style="font-style:italic">logistics</span><span>. This means storing goods at centers around the world, but also being incredibly efficient at getting those goods from suppliers, and to customers. Optimizing their transportation needs is a </span><span style="font-weight:bold">graph theory</span><span> problem easily worth many hundreds of millions of dollars every year to Amazon, likely $1Billion or more. </span></p><p><span>&#xa0;</span></p><p><span>Large software projects such as Office, Android or World of Warcraft have highly complex processes required to build these products. From synchronizing source code, to compiling and linking source code, to substituting localized text strings for more than 100 non-English languages, to creating installable packages, to automatically installing and testing a daily build, to automatically releasing it to the large team of engineers </span><span style="font-style:italic">only if the builds and tests pass</span><span> – there are hundreds of steps that can be automated, with numerous interdependencies. Constructing a dependency chains for large software projects that works at all – let alone optimizing it – is an enormous graph theory problem. Looking more deeply into just one of these steps – compiling and linking an iOS application: these tools could not </span><span style="font-style:italic">begin</span><span> to interpret source code without significant use of dependency analysis, rooted in graph theory. </span></p><p><span>&#xa0;</span></p><p><span>Every network problem is a graph problem as well. Is there enough Internet backbone bandwidth for future needs? Although our roads and bridges might be adequate for average demands, can we forecast how they will fare during events such as local NFL games or university graduations? The modern industrial company deals with complicated dependency chains (graphs) when they manage their materials and their manufacturing lines. Social network companies such as Facebook, LinkedIn, Twitter consider their knowledge of the interconnections between us to be their core asset. </span><span style="font-style:italic">Org charts</span><span> that show teams and leadership relationships are graphs. Even our understanding of how the human brain works (a neural network) is modeled as a complex and enormous graph. Graphs are extremely important, if for no other reason than that our world is increasingly a </span><span style="font-style:italic">connected</span><span> one. </span></p><p><span>&#xa0;</span></p><p><span>What is a graph? How do we process and manage them in computing? Why are there different ways to represent them? Where and when is each method appropriate? </span></p><p><span>&#xa0;</span></p><p><span>A graph is any collection of nodes that can be connected. Singly linked lists and binary trees, for example, are graphs. When we look at a graph on a computer screen or on paper, the actual shape of that graph does not matter – what matters are the connections between nodes. The number of connections out of or into each node need not be limited to just one or two: it is possible for every node to be connected to every other. Also, the connections between nodes may or may not have </span><span style="font-style:italic">direction</span><span> (the ‘arrows’ between nodes may not have ‘arrowheads’). Connections also may or may not have a </span><span style="font-style:italic">weight</span><span> that we choose to store within it. For example, if downtown intersections A and B are nodes, for the connection between them we could use its weight to signify the distance between them, or the time needed to travel between them, or the cost in fuel+toll. Hopefully you are starting to see how programs like Google Maps might store a city transportation grid! There are two common ways graphs are represented in data structures. Before we go into those, we need to define a few common terms. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 17</span><span> – Graphs</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>