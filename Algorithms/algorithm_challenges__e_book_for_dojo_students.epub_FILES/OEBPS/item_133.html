<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_130"><span>Rotation</span></h2><p><span>The benefit of AVL trees over other BSTs is that AVL trees automatically keep themselves relatively balanced. When an AVL tree discovers an imbalance (if any node’s left subtree height and right subtree height differ by more than one), it fixes that condition by </span><span style="font-style:italic">rotating</span><span> that node. </span></p><p><span>&#xa0;</span></p><p><span>Think of rotation as a clockwise (Rotate Right) or counter-clockwise (Rotate Left) shift of both the node in question as well as its “tall” child node. Child is promoted above parent, reducing overall tree height. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Consider a large BST where in the midst of the tree, node A has a </span><span class="CodeSnippet" style="font-family:Times, serif">.right</span><span> child: node B. Following an insertion somewhere below B, node A’s right subtree height is now two greater than its left subtree height. We should </span><span style="font-style:italic">Rotate-</span><span style="font-style:italic">Left</span><span> node A. This will change the height for A and B, but how are all the other nodes affected? It would be expensive to move lots of nodes around whenever we do a rotation.</span></p><p><span>&#xa0;</span></p><p><span>Fortunately, this isn’t the case. Think about where the rest of the nodes in the tree </span><span style="font-style:italic">end up</span><span>, when we do a rotation</span><span>. To </span><span>start with, nodes above this rotation do not move, nor do those in other parts of the tree. As a </span><span>result,</span><span> we only need to worry about A’s and B’s children. Those children have values that are either </span></p><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; text-indent:-18pt"><span style="font-size:0.91em; text-decoration:none">a)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>less than A’s (conveniently located under </span><span class="CodeSnippet" style="font-family:Times, serif">A.left</span><span>), or </span></p><p class="ListParagraph" style="line-height:115%; margin-bottom:0pt; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em; text-decoration:none">b)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>greater than/equal to B’s (conveniently located under </span><span class="CodeSnippet" style="font-family:Times, serif">B.right</span><span>), or </span></p><p class="ListParagraph" style="line-height:115%; margin-left:36pt; margin-top:0pt; text-indent:-18pt"><span style="font-size:0.91em; text-decoration:none">c)</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>between A and B (</span><span style="font-style:italic">currently</span><span> conveniently located under </span><span class="CodeSnippet" style="font-family:Times, serif">B.left</span><span>). </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 19</span><span> – Trees, Part III</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="line-height:115%"><span>When we </span><span class="CodeSnippet" style="font-family:Times, serif">rotateLeft</span><span> node A, it becomes the </span><span class="CodeSnippet" style="font-family:Times, serif">.left</span><span> of node B. Let’s put their groups of children in place. Child nodes less than A (the entire </span><span class="CodeSnippet" style="font-family:Times, serif">A.left</span><span> subtree) should stay where they are. Nodes greater than B (the </span><span class="CodeSnippet" style="font-family:Times, serif">B.right</span><span> subtree) should also stay put. However, nodes </span><span style="font-style:italic">in between</span><span> might pose a problem. They can’t stay where they are (under </span><span class="CodeSnippet" style="font-family:Times, serif">B.left</span><span>), because that’s where A has moved. What to do? </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Let’s reason through this. Nodes in question have values less than B, so they go to B’s </span><span style="font-style:italic">left</span><span> somewhere. They have values greater than A, so they go to A’s </span><span style="font-style:italic">right</span><span> somewhere. After promoting B, </span><span class="CodeSnippet" style="font-family:Times, serif">A.right</span><span> is available! Subtree previously located at </span><span class="CodeSnippet" style="font-family:Times, serif">B.left</span><span> can move to </span><span class="CodeSnippet" style="font-family:Times, serif">A.right</span><span>. </span><span style="font-style:italic">Voila!</span><span> Rotate-Left is complete. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%; text-align:center"><img src="item_040.png" width="197" height="168" alt="" style="float:left; margin:0pt 9pt" /><span>Calling </span><span class="CodeSnippet" style="font-family:Times, serif">rotateLeft(Q)</span><span> on </span><span>first </span><span>tree converts it to </span><span>the second one</span><span>. Cool! In most (not all) cases, one rotation corrects </span><span>an </span><span>imbalance. Drawing diagrams, you may discover </span><span style="font-style:italic">corner cases</span><span> where rotation does not succeed. </span></p><p style="text-align:center"><img src="item_070.png" width="197" height="154" alt="" style="float:left; margin:0pt 9pt" /></p><p style="line-height:115%"><span>Revisiting </span><span>the </span><span>first</span><span> tree: what if a tall </span><span class="CodeSnippet" style="font-family:Times, serif">T</span><span> subtree causes our imbalance? After </span><span class="CodeSnippet" style="font-family:Times, serif">rotateLeft</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">T</span><span> shifts from </span><span class="CodeSnippet" style="font-family:Times, serif">S.left</span><span> to </span><span class="CodeSnippet" style="font-family:Times, serif">Q.right</span><span> but does not move toward root; imbalance remains. Our objective was to pull a ‘tall grandchild’ toward root.</span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><img src="item_012.png" width="185" height="182" alt="" style="float:left; margin:0pt 9pt" /><span>Note </span><span>the next</span><span> graph</span><span>. If </span><span class="CodeSnippet" style="font-family:Times, serif">.left</span><span> of a tall right child causes imbalance, we can’t just </span><span class="CodeSnippet" style="font-family:Times, serif">rotateLeft(Q)</span><span>. </span><span>We must</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">rotateRight(S)</span><span> to transform</span><span> </span><span>it </span><span>into </span><span>this </span><span>tree.</span></p><p><img src="item_149.png" width="218" height="190" alt="" style="float:left; margin:0pt 9pt" /></p><p style="line-height:115%"><span style="font-style:italic; text-decoration:underline">Then</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">rotateLeft(Q)</span><span> transforms middle tree into (shallower) final tree.</span><span> </span></p><p><img src="item_113.png" width="265" height="134" alt="" style="float:left; margin:0pt 9pt" /></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">AVL: R</span><span style="font-size:0.86em">otate Left</span></p><p style="line-height:115%"><span>Create </span><span class="CodeSnippet" style="font-family:Times, serif">rotateLeft(node)</span><span> method in the </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span> class. First counter-rotate the child if needed, and as always update</span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span> attributes appropriately and inexpensively. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">AVL: R</span><span style="font-size:0.86em">otate Right</span></p><p style="line-height:115%"><span>Create a </span><span class="CodeSnippet" style="font-family:Times, serif">rotateRight(node)</span><span> method for </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span>. Counter-rotate the ‘tall child’ first, if needed, and keep all </span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span> attributes appropriately and inexpensively up-to-date.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 19</span><span> – Trees, Part III</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; font-size:0.73em; line-height:115%; padding-top:1pt"><span>&#xa0;</span></p><p style="line-height:115%"><img src="item_012.png" width="185" height="182" alt="" style="float:left; margin:0pt 9pt" /><span>Let’s review how nodes move, on our previous Right-Left Rotation</span><span>. If </span><span class="CodeSnippet" style="font-family:Times, serif">.left</span><span> of a </span><span>tall</span><span> right child causes imbalance (specifically </span><span class="CodeSnippet" style="font-family:Times, serif">T</span><span>), then before we </span><span class="CodeSnippet" style="font-family:Times, serif">RotateLeft(Q)</span><span> we </span><span class="CodeSnippet" style="font-family:Times, serif">RotateRight(S)</span><span>, transforming </span><span>first</span><span> tree into </span><span>second</span><span> tree. Then, </span><span class="CodeSnippet" style="font-family:Times, serif">RotateLeft(Q)</span><span> transforms </span><span>second</span><span> tree into (shallower) </span><span>third</span><span> tree.</span><span> </span></p><p style="font-size:0.73em; line-height:115%"><img src="item_149.png" width="218" height="190" alt="" style="float:left; margin:0pt 9pt" /></p><p style="line-height:115%"><img src="item_113.png" width="265" height="134" alt="" style="float:left; margin:0pt 9pt" /><span style="font-style:italic">Note: in this example, the heights of </span><span style="font-style:italic; font-weight:bold; text-decoration:underline">child</span><span style="font-style:italic"> nodes (</span><span class="CodeSnippet" style="font-family:Times, serif">R</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">V</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">W</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">U</span><span style="font-style:italic">) don’t change during the rotation process</span><span>; the heights of all nodes in those subtrees are unaffected, all the way down to the leaves. Heightwise, the only affected nodes are red, black, and green – </span><span>as well as their parent chain</span><span>. For this </span><span>reason,</span><span> when fixing heights after a rotation we must follow any change upward to the parent, in case that parent’s height changed as well. In what scenario should we </span><span style="font-style:italic">not</span><span> continue to notify upward? Specifically, if after </span><span style="font-style:italic">adding</span><span> some value we see a node’s </span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span> change (say, from 1) </span><span style="font-style:italic; text-decoration:underline">to 0</span><span>, then that node’s height did not change, and hence its parent chain is unaffected. Similarly, if after </span><span style="font-style:italic">removing</span><span> some value we see a node’s </span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span> change from 0 to some other value, then that node’s height did not change (try drawing a few on paper!). If a node’s height didn’t change, there’s no need to check its parent nodes. This significantly optimizes our </span><span>Update Balance Indices</span><span> process. </span></p><p style="font-size:0.73em; line-height:115%"><span>&#xa0;</span></p><p style="line-height:115%"><span>Now that we can 1) add and remove while updating</span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span>, as well as 2) rotate to bring trees back into balance, we are equipped to create the most powerful </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span> methods: </span><span style="font-style:italic; text-decoration:underline">balanced add</span><span style="font-style:italic; text-decoration:underline"> / </span><span style="font-style:italic; text-decoration:underline">remove</span><span>. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">AVL: B</span><span style="font-size:0.86em">alanced Add</span></p><p style="line-height:115%"><span>Using all you learned this chapter, create a </span><span class="CodeSnippet" style="font-family:Times, serif">balancedAdd(value)</span><span> method for </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span> class. Ensure that by the time it returns, our value is added, the tree is balanced, and all node attributes are updated and accurate. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">AVL: B</span><span style="font-size:0.86em">alanced Remove</span></p><p style="line-height:115%"><span>Build </span><span class="CodeSnippet" style="font-family:Times, serif">balancedRemove(value)</span><span> for our </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span> class. Ensure that when method returns (</span><span class="CodeSnippet" style="font-family:Times, serif">true</span><span> if removed, </span><span class="CodeSnippet" style="font-family:Times, serif">false</span><span> if not found), the value is removed, tree is balanced, and all node attributes</span><span> are updated and accurate. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">AVL: R</span><span style="font-size:0.86em">ebalance</span></p><p style="line-height:115%"><span>Similar to </span><span class="CodeSnippet" style="font-family:Times, serif">r</span><span class="CodeSnippet" style="font-family:Times, serif">epair()</span><span> on regular </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>s, create </span><span class="CodeSnippet" style="font-family:Times, serif">r</span><span class="CodeSnippet" style="font-family:Times, serif">ebalance()</span><span> for </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span>s. Just as </span><span class="CodeSnippet" style="font-family:Times, serif">r</span><span class="CodeSnippet" style="font-family:Times, serif">epair()</span><span> is not really needed (since we expect </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>s to insert and delete nodes correctly and never become invalid), similarly we could argue that </span><span class="CodeSnippet" style="font-family:Times, serif">r</span><span class="CodeSnippet" style="font-family:Times, serif">ebalance()</span><span> is unneeded since </span><span>an</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">AVL</span><span class="CodeSnippet" style="font-family:Times, serif">T</span><span class="CodeSnippet" style="font-family:Times, serif">ree</span><span> will continually keep itself balanced. Nonetheless, quickly build this, using other methods you’ve already created. </span></p><p style="font-size:1.09em; line-height:115%"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 19</span><span> – Trees, Part III</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>There are other types of self-balancing tree as well. One example is the Red-Black Tree.</span></p></div></body></html>