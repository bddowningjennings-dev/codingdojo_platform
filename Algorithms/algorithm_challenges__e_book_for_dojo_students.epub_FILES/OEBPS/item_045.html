<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_129"><span>AVL Trees</span></h2><p><span>Remember that a binary search tree’s performance is linked to how balanced it is. If a tree is unbalanced and deep, then there is a chance that the value we seek is down in the depths of the tree, far beyond the average expected height. But what if our BST could somehow keep itself balanced? How would it do this, and how expensive would it be? Soviet mathematicians Georgy Adelson-Velsky and Evgenii Landis responded to this problem by inventing the first self-balancing tree: named after their surname initials, we call it the </span><span style="font-weight:bold">AVL tree</span><span>. </span></p><p><span>&#xa0;</span></p><p><span>The rules of an AVL tree are simple: for every node, the heights of its two child subtrees must differ by at most one. If an insertion or removal changes the tree so that this rule is no longer valid (in other words, an insertion or removal makes the tree </span><span style="font-style:italic">unbalanced</span><span>), the tree must ‘rotate’ its shape to become balanced again</span><span>. To </span><span>optimize the AVL tree for the fact that it will constantly check its balance at various locations, each node contains (and maintains) a </span><span style="font-style:italic">balance factor</span><span> (1 if its left subtree is one node deeper than its right subtree, -2 if the right subtree is deeper by two, 0 if both sides are even, etc). For today, let’s just measure and detect these situations; tomorrow we will address them. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Code" style="text-indent:0pt"><span>function AVLTree() {</span></p><p class="Code"><span>var head = null;</span></p><p class="Code"><span>&#xa0;</span></p><p class="Code"><span>this.add = function(value) {}</span></p><p class="Code"><span>this.remove = function(value){}</span></p><p class="Code"><span>// Assume these exist and</span></p><p class="Code"><span>// correctly update node.balance</span></p><p class="Code"><span>&#xa0;</span></p><p class="Code"><span>this.height = function() {</span></p><p class="Code" style="margin-left:36pt; text-indent:0pt"><span>// ...write this code today</span></p><p class="Code"><span>}</span></p><p class="Code"><span>this.isBalan</span><span>ced = function()</span><span>{</span></p><p class="Code" style="margin-left:36pt; text-indent:0pt"><span>// ...write this code today</span></p><p class="Code"><span>}</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p><p class="Code" style="text-indent:0pt"><span>function AVLNode(value) {</span></p><p class="Code"><span>this.val = value;</span></p><p class="Code"><span>&#xa0;</span></p><p class="Code"><span>this.balance = 0;</span></p><p class="Code"><span>this.left = null;</span></p><p class="Code"><span>this.right = null;</span></p><p class="Code"><span>&#xa0;</span></p><p class="Code"><span>this.height = function() {</span></p><p class="Code" style="margin-left:36pt; text-indent:0pt"><span>// ...write this code today</span></p><p class="Code"><span>}</span></p><p class="Code"><span>this.isBalanced = function() {</span></p><p class="Code" style="margin-left:36pt; text-indent:0pt"><span>// ...write this code today</span></p><p class="Code"><span>}</span></p><p class="Code" style="text-indent:0pt"><span>}</span><span> </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">AVL</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> H</span><span style="font-size:0.86em">eight</span></p><p style="line-height:115%"><span>Create</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">height()</span><span> methods for </span><span>both the </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">AVLNode</span><span> </span><span>classes</span><span>. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">AVL</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> I</span><span style="font-size:0.86em">s Balanced</span></p><p style="line-height:115%"><span>Given </span><span>an </span><span>AVL tree w</span><span>hose nodes have </span><span>up-to-date </span><span class="CodeSnippet" style="font-family:Times, serif">.b</span><span class="CodeSnippet" style="font-family:Times, serif">alance</span><span> val</span><span>ue</span><span>s, create</span><span> the</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">isBalanced()</span><span> methods f</span><span>or </span><span>both </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span> &amp; </span><span class="CodeSnippet" style="font-family:Times, serif">AVLNode</span><span>.</span><span> </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 19</span><span> – Trees, Part III</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>AVL trees are a type of </span><span style="font-style:italic">self-balancing tree</span><span> (we touch on other variants later). The motivation for staying balanced is </span><span style="text-decoration:underline">efficiency</span><span>: unbalanced trees do not add/remove/find as quickly. However, keeping balanced might be expensive; if we aren’t careful, the costs eclipse the benefits. How can we minimize costs? </span></p><p><span>&#xa0;</span></p><ol style="list-style-type:decimal; margin:0pt; padding-left:0pt"><li class="ListParagraph" style="font-family:Arial; margin-left:32.17pt; padding-left:3.83pt; text-indent:0pt"><span style="font-family:Arial">Minimize the cost of </span><span style="font-family:Arial; text-decoration:underline">checking</span><span style="font-family:Arial"> a tree’s cost. This implies that we:</span></li></ol><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>a. </span><span>Store a value in each node, rather than recomputing height/balance each time;</span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>b. </span><span>Store </span><span style="font-style:italic">balance, </span><span>not height, to avoid checking children when testing for balance; </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>c. </span><span>Check the tree’s balance only at appropriate times; </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>d. </span><span>Check the tree’s balance only at necessary tree locations. </span></p><p class="ListParagraph" style="margin-left:36pt; text-indent:-18pt"><span>2.</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Minimize the cost of </span><span style="text-decoration:underline">maintaining</span><span> the tree’s balance indices, implying that we: </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>a. </span><span>Only update the balance indices when we add/remove values (or rebalance); </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>b. </span><span>Update balance indices for </span><span style="font-style:italic">only nodes affected</span><span> by the add/remove, so that we </span><br /><span>minimize the number of nodes whose balance need rechecking (see 1c). </span></p><p class="ListParagraph" style="margin-left:36pt; text-indent:-18pt"><span>3.</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Minimize the cost of </span><span style="text-decoration:underline">rebalancing</span><span> the tree, when this is needed. This implies that we: </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>a. </span><span>Minimize the number of nodes changed during a rebalance, so that in turn we</span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>b. </span><span>Need to update </span><span style="font-style:italic">balance</span><span> for only a small number of nodes (see 2b), in order to </span><br /><span>minimize the number of nodes whose balance needs rechecking (see 1c). </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>What does 1b mean? </span><span class="CodeSnippet" style="font-family:Times, serif">AVLNode.isBalanced()</span><span> is inexpensive if we maintain </span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span> – it’s a quick attribute check. If instead we store </span><span class="CodeSnippet" style="font-family:Times, serif">.height</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">isBalanced()</span><span> requires checking and comparing heights of both children. This makes </span><span style="font-style:italic">updating </span><span>balance </span><span>trickier</span><span> but contributes to a successful item 1 in our list. Method </span><span class="CodeSnippet" style="font-family:Times, serif">height()</span><span>is less critical, but</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span> tells us which way to branch as we dive to the deepest leaf. It isn’t </span><span class="CodeSnippet" style="font-family:Times, serif">O(1)</span><span>, but it is </span><span class="CodeSnippet" style="font-family:Times, serif">O(NlogN</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span>, which is good enough. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Let’s explore 2a and 2b. Remember those methods that yesterday we glossed over, </span><span style="font-style:italic">assuming </span><span>they already existed? We will create them today. Write </span><span class="CodeSnippet" style="font-family:Times, serif">add(value)</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">remove(value)</span><span> methods for the </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span> class. When you do so, remember to keep the </span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span> attribute up-to-date for each node. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Code" style="text-indent:0pt"><span>function AVLTree() {</span></p><p class="Code"><span>var head = null;</span></p><p class="Code"><span style="background-color:#c0c0c0">// assume isBalanced() works fine</span></p><p class="Code"><span>this.isBalanced = function() {}</span></p><p class="Code"><span style="background-color:#c0c0c0">&#xa0;</span></p><p class="Code"><span style="background-color:#c0c0c0">// ...write these today</span></p><p class="Code"><span>this.add = function(value) {}</span></p><p class="Code"><span>this.remove = function(value){}</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p><p class="Code" style="text-indent:0pt"><br style="mso-column-break-before:always; clear:both" /><span>function AVLNode(value) {</span></p><p class="Code"><span>this.val = value;</span></p><p class="Code"><span>this.balance = 0;</span></p><p class="Code"><span>this.left = null;</span></p><p class="Code"><span>this.right = null;</span></p><p class="Code"><span style="background-color:#c0c0c0">&#xa0;</span></p><p class="Code"><span style="background-color:#c0c0c0">// assume isBalanced() works fine</span></p><p class="Code"><span>this.isBalanced = function() {}</span></p><p class="Code" style="text-indent:0pt"><span>}</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">AVL</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> Remove</span></p><p style="line-height:115%"><span>Create </span><span class="CodeSnippet" style="font-family:Times, serif">remove(value)</span><span> for the </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span> class. Update </span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span> for any affected nodes, but don’t worry about rebalancing the tree.</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">AVL: Add</span></p><p style="line-height:115%"><span>Create </span><span class="CodeSnippet" style="font-family:Times, serif">add(value)</span><span> for the </span><span class="CodeSnippet" style="font-family:Times, serif">AVLTree</span><span> class. Update </span><span class="CodeSnippet" style="font-family:Times, serif">.balance</span><span> for any affected nodes, but don’t worry about rebalancing the tree. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 19</span><span> – Trees, Part III</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>Let’s review the challenges we face, if we want an AVL tree to have high performance:</span></p><p><span>&#xa0;</span></p><ol style="list-style-type:decimal; margin:0pt; padding-left:0pt"><li class="ListParagraph" style="font-family:Arial; margin-left:32.17pt; padding-left:3.83pt; text-indent:0pt"><span style="font-family:Arial">Minimize the cost of </span><span style="font-family:Arial; text-decoration:underline">checking</span><span style="font-family:Arial"> a tree’s cost. This implies that we:</span></li></ol><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>a. </span><span>Store a value in each node, rather than recomputing height/balance each time;</span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>b. </span><span>Store </span><span style="font-style:italic">balance, </span><span>not height, to avoid checking children when testing for balance; </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>c. </span><span>Check the tree’s balance only at appropriate times; </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>d. </span><span>Check the tree’s balance only at necessary tree locations. </span></p><p class="ListParagraph" style="margin-left:36pt; text-indent:-18pt"><span>2.</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Minimize the cost of </span><span style="text-decoration:underline">maintaining</span><span> the tree’s balance indices, implying that we: </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>a. </span><span>Only update the balance indices when we add/remove values (or rebalance); </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>b. </span><span>Update balance indices for </span><span style="font-style:italic">only nodes affected</span><span> by the add/remove, so that we </span><br /><span>minimize the number of nodes whose balance need rechecking (see 1c). </span></p><p class="ListParagraph" style="margin-left:36pt; text-indent:-18pt"><span>3.</span><span style="font:7.0pt 'Times New Roman'">&#xa0;&#xa0;&#xa0;&#xa0;&#xa0; </span><span>Minimize the cost of </span><span style="text-decoration:underline">rebalancing</span><span> the tree, when this is needed. This implies that we: </span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>a. </span><span>Minimize the number of nodes changed during a rebalance, so that in turn we</span></p><p style="margin-left:51.1pt; text-indent:-15.1pt"><span>b. </span><span>Need to update </span><span style="font-style:italic">balance</span><span> for only a small number of nodes (see 2b), in order to </span><br /><span>minimize the number of nodes whose balance needs rechecking (see 1c). </span></p><p><span>&#xa0;</span></p><p><span>For 2a and 2b, as you discovered yesterday, we minimize the cost of updating balance indices by only updating the balance of nodes being inserted/removed and their ancestors upward (</span><span style="font-style:italic">not</span><span> the entire tree). When an ancestor node’s balance is unaffected, we need not continue checking upward. </span></p><p><span>&#xa0;</span></p><p><span>What about our other major implication: rebalancing? We handle this with an operation called </span><span style="font-style:italic">rotation</span><span>. </span></p></div></body></html>