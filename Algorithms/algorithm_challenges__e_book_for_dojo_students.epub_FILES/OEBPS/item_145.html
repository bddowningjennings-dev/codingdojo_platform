<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_117"><span>Depth-First Search</span></h2><p style="line-height:115%"><span>With depth-first iteration, we continue along a chosen path until it ends before exploring alternate paths. If we are iterating a </span><span style="font-style:italic">BST</span><span>, we know that a path ends when child pointers are </span><span class="CodeSnippet" style="font-family:Times, serif">NULL</span><span>, and we recurse until we get there. For </span><span>graphs,</span><span> we’ll need a different way, since graphs can have loops. Rather than using recursion (which uses a </span><span style="font-style:italic">call </span><span>stack) to handle </span><span>backtracing</span><span> through all the possibilities, we will use a stack of our own; as we discover new possible vertices, we add them to our stack</span><span>. To </span><span>prevent our iterating into infinite loops, we will mark each vertex when we visit it. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>We start the Depth-First Search (DFS) process on a graph by marking the source vertex as </span><span style="font-style:italic">visited</span><span>, then pushing it onto our stack. Then we enter the main loop, which continues until the stack is empty. The loop begins by popping the next vertex from our stack. Is this the vertex we are looking for? If so, we exit our loop by immediately </span><span class="CodeSnippet" style="font-family:Times, serif">return</span><span>ing with success. Otherwise, we retrieve the neighbors for this vertex. For those neighbors that have not yet been visited, we push them onto our stack and restart the loop, when we again pop a vertex from our stack. Eventually, if we have not found our vertex, we will stop finding unvisited vertices and the stack will be emptied. If we exit our loop, then we have iterated the graph without finding our target vertex, so we return an appropriate failure (such as </span><span class="CodeSnippet" style="font-family:Times, serif">false</span><span> or </span><span class="CodeSnippet" style="font-family:Times, serif">[]</span><span>). In short, DFS dives deep immediately rather than methodically advancing along all paths. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Someone </span><span style="font-size:0.86em">on</span><span style="font-size:0.86em"> the Inside</span></p><p><span>Everybody knows that it is easier to get a job at a company when you know someone </span><span>that already works</span><span> there – you can learn the culture, what technologies they use, what teams are hiring, etc. – all b</span><span>efore making official contact! Using graph operations, d</span><span>etermine whether you know someone “on the inside” at your target company, and if so, who. You are given an undirected graph </span><span>(</span><span>representing your </span><span>social </span><span>network</span><span>)</span><span>, your own vertex ID, and an array of vertex IDs for those working at the company.</span></p><p><span>&#xa0;</span></p><p><span style="font-weight:bold">Second:</span><span> </span><span>often you </span><span style="font-style:italic">won’t</span><span> know anyone “on the inside” at your target. If so, find one of your contacts that does, returning vertex IDs for contact and insider. Can you optimize the performance of your solution? </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Vertex Is Reachable</span></p><p><span>Given a generalized graph and two vertex IDs, return whether a path exists from first to second vertex. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span style="font-weight:bold">Second:</span><span> on success, return array of vertex IDs representing one possible path. If none exist, return </span><span class="CodeSnippet" style="font-family:Times, serif">[]</span><span>. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">All Paths</span></p><p><span>Given a graph, as well as IDs for source and destination vertices, return an array of all possible paths from source to destination. A path cannot revisit a vertex. If no path exists, return an empty array. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 17</span><span> – Graphs</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>