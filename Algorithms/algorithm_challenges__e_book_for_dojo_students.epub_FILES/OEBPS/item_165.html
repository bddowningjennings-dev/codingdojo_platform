<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_106"><span>Trie Data Structure</span></h2><p><span>The </span><span style="font-style:italic">trie </span><span>data structure (initially pronounced “</span><span>tree</span><span>” as the middle syllable of </span><span style="font-style:italic">re</span><span style="font-style:italic; text-decoration:underline">trie</span><span style="font-style:italic">val</span><span>, but now universally pronounced “</span><span style="font-style:italic; font-weight:bold">try</span><span>” to avoid confusion) is useful in scenarios usually reserved for a hash, but it is best known for its power to predict – particularly auto-complete. Let’s examine the trie </span><span style="font-style:italic">conceptually</span><span>.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><img src="item_018.png" width="400" height="353" alt="" style="float:left; margin:0pt 9pt" /></p><p style="page-break-inside:avoid"><span>As shown </span><span>in the diagram</span><span>, a trie is a set of connected nodes. The root node represents the empty string “”; from that node, there can be many pointers to other nodes. Each pointer+node represents the addition of a letter to that sequence. If the sequence of letters adds up to a word, then the word is stored within the node as well. If not, it still exists in the trie if it is needed for another, longer word (like the ‘R’ node below the top-level ‘A’). Because each node represents a unique word, two parent nodes can never point to the same child node – although ‘ATE’ and ‘ARE’ are both in our trie, the ‘AR’ node and the ‘AT’ node point to different children for an additional ‘E’. </span></p><p style="page-break-inside:avoid"><span>&#xa0;</span></p><p style="page-break-inside:avoid"><span>Nodes are added only when they are needed to store a word – the diagram above represents the words “a”, “are”, “</span><span>arf</span><span>”, “as”, “asp”, “at”, “ate”, “atom”, “atop” and “I”. If we were to add the word “asps”, a pointer representing “s” would extend from the “ASP” node to a new node containing “ASPS”. If we add the word “</span><span>ar</span><span>”, a node already exists at the appropriate location, so “AR” would be stored into the node. </span></p><p style="page-break-inside:avoid"><span>&#xa0;</span></p><p style="line-height:115%; page-break-inside:avoid"><span>Codewise, a </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span> object is quite similar to a basic binary tree object: it contains a single attribute – a pointer to the root node – plus the instance methods. Each </span><span class="CodeSnippet" style="font-family:Times, serif">TrieNode</span><span> object contains an optional node value, plus an array of pointers. This array is initially empty but can hold as many pointers as there are letters in the alphabet. If we choose to lower-case all the strings that we hold in our </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span>, then each node’s array could contain as many as 26 pointers. Again, each pointer+node represents the addition of a specific letter to the sequence of letters from the root up to that node. </span></p><p style="page-break-inside:avoid"><span>&#xa0;</span></p><p style="page-break-inside:avoid"><span>T</span><span>o</span><span> add a word to our trie, we iterate each letter, following the appropriate pointer for that letter. If the node’s array has no pointer there, we create a node, write it to the array location and proceed. When we reach the last letter, we save the word in the node, signifying that it is </span><span style="font-style:italic">terminal</span><span>, not intermediate. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 16</span><span> – Tries</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="line-height:115%"><span>After walking through a trie in both concept and code, hopefully you see how tries might enable one to predict the word, given the first few letters! Implement the following challenges to create a </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span>:</span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Trie</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> Insert</span></p><p style="line-height:115%"><span>After building simple </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">TrieNode</span><span> constructors, create an </span><span class="CodeSnippet" style="font-family:Times, serif">a</span><span class="CodeSnippet" style="font-family:Times, serif">dd</span><span> method to insert a string to the set. For our purposes, assume that input strings will be letters only – no numerals or punctuation. Also, you can convert inputs to lowercase before storing them. Return </span><span class="CodeSnippet" style="font-family:Times, serif">false</span><span> if word has already been stored (after all, it’s a </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span> not a </span><span class="CodeSnippet" style="font-family:Times, serif">TrieMulti</span><span class="CodeSnippet" style="font-family:Times, serif">Set</span><span>!), or </span><span class="CodeSnippet" style="font-family:Times, serif">true</span><span> if insertion is successful. Tries are treelike (not a purely linear one like a linked list), so recursion at the node level is a reasonable choice.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Trie</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> Contains</span></p><p style="line-height:115%"><span>Create a </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span> method to check whether a given string is present within the set. Again, you can assume that all inputs are letters-only; you can also convert all strings to lowercase. Return </span><span class="CodeSnippet" style="font-family:Times, serif">true</span><span> if word is found, </span><span class="CodeSnippet" style="font-family:Times, serif">false</span><span> if not. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Trie</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> First</span></p><p style="line-height:115%"><span>Tries are reasonable substitutes for Hashes, yet they retain order! Build a method to return trie’s first value. </span><span style="font-style:italic">First</span><span> means </span><span style="font-style:italic">lowest-</span><span style="font-style:italic">alphabetically</span><span>, not earliest-added. N.B.: </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">Todd</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span> comes before </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">toddy</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span>.</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Trie</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> Last</span></p><p style="line-height:115%"><span>Return </span><span>its</span><span> </span><span style="font-style:italic">last</span><span> value. </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">Kelvin</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span> comes after </span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span class="CodeSnippet" style="font-family:Times, serif">kelp</span><span class="CodeSnippet" style="font-family:Times, serif">"</span><span>.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Trie</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> Remove</span></p><p style="line-height:115%"><span>Construct a method in </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span> class that removes a given string from our set. As earlier, safely assume that all input strings will contain only letters (not numerals or punctuation). Also, lowercase all strings before storing or checking for them. When removing trie values, remember that in some cases you need to remove a terminal </span><span class="CodeSnippet" style="font-family:Times, serif">TrieNode</span><span>. You may potentially need to remove certain ancestor intermediate nodes. Make sure to return </span><span class="CodeSnippet" style="font-family:Times, serif">true</span><span> on a successful removal, </span><span class="CodeSnippet" style="font-family:Times, serif">false</span><span> if string not found. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span style="font-weight:bold">Second: </span><span>Incorporate punctuation and case-sensitivity across the </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span> class. Suggestion: the 95 typeable characters on a keyboard have consecutive charCode values, starting with [space]. </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 16</span><span> – Tries</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="line-height:115%"><span>Today, finish </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span>. Auto-complete is used by search engines and mobile devices. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Trie</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> Size</span></p><p style="line-height:115%"><span>Return the number of values added to the </span><span class="CodeSnippet" style="font-family:Times, serif">TrieSet</span><span>. There are two valid ways to implement this method – can you come up with both? In which usage cases would you prefer one over the other? </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Trie</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> Next</span></p><p style="line-height:115%"><span>Given a string that might not be in the trie, return the contained string that is immediately subsequent. Hashes don’t do well with this, but tries can! Return </span><span class="CodeSnippet" style="font-family:Times, serif">null</span><span> if there is no subsequent string. </span></p><p><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Trie</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> Auto Complete</span></p><p><span>Assume your trie is populated with a wide array of valid words. Given string (presumably what user typed so far), use your trie to rapidly return an array of words beginning with that string. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span style="font-weight:bold">Second:</span><span> augment </span><span class="CodeSnippet" style="font-family:Times, serif">autoComplete(str)</span><span> to accept </span><span class="CodeSnippet" style="font-family:Times, serif">maxResults</span><span>, and return at most that many. </span></p><p><span>&#xa0;</span></p><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 16</span><span> – Tries</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>