<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_80"><span>Binary Tree Depth</span></h2><p class="Normal1"><span>A tree</span><span>’</span><span>s </span><span style="font-weight:bold">depth</span><span> is the le</span><span>ngth from root to farthest leaf</span><span> including both. If </span><span>we</span><span> add nodes to a </span><span>BST</span><span> in random order, the tree grows in a relatively </span><span style="font-style:italic">balanced</span><span> manner – left </span><span>and right subtrees will be about the same size, </span><span>with </span><span>mostly equal depth. If </span><span>we</span><span> add elements in </span><span style="font-style:italic">sorted</span><span> order, the tree become</span><span>s</span><span> </span><span style="font-style:italic">unbalanced</span><span>, resembling a linked list in shape, and depth might approach the total number of elements. Even balanced trees </span><span>often</span><span> have </span><span>a few “</span><span>holes</span><span>”</span><span> </span><span>where non-leaf nodes have one child that is NULL. However, t</span><span>he fewer </span><span>the </span><span>holes, the </span><span>fuller</span><span> a BST is</span><span>. </span><span>Using the tree metaphor, a full BST is a very “bushy” tree, rather than thin and spindly. More nodes, contained </span><span>in the same </span><span>number of layers, makes for a better tree. Stated differently, g</span><span>iven two </span><span>binary </span><span>trees with the same number of nodes, </span><span>the</span><span> </span><span>one with less depth is always </span><span>more </span><span>efficient. Why is this? </span></p><p class="Normal1"><span>&#xa0;</span></p><p><span>Our answer lies in the reason that f</span><span>inding values in BSTs </span><span>is</span><span> </span><span>so much</span><span> </span><span>quicker</span><span> than </span><span>finding them </span><span>in SLists. </span><span>Every node in a binary tree has branches, so there isn’t a single path to follow from beginning node to end node. Furthermore, because </span><span>BSTs are ordered, </span><span>we</span><span> </span><span>always choose the correct direction at every fork</span><span>. Instead of searching all values, the longest search is only the </span><span>depth of the tree</span><span>. This is why </span><span>shallow, </span><span>full trees are best. As data structures go, BSTs </span><span style="font-style:italic">rock</span><span> for fast retrieval</span><span> and maintaining order. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Today, add these additional methods to our </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> class implementation:</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: Height</span></p><p style="line-height:115%"><span>Build a </span><span class="CodeSnippet" style="font-family:Times, serif">height()</span><span> method on the </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> object that returns the total height of the tree – the longest sequence of nodes from root node to leaf node.</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">BST: Is Balanced</span></p><p style="line-height:115%"><span>Write </span><span class="CodeSnippet" style="font-family:Times, serif">isbalanced()</span><span>method to indicate whether a </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> is balanced. For this challenge, consider a tree balanced when </span><span style="font-style:italic">all</span><span> nodes are balanced. A </span><span class="CodeSnippet" style="font-family:Times, serif">BTNode</span><span> is balanced if heights of its left subtree and right subtree differ by at most one. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Array to BST</span></p><p style="line-height:115%"><span>Given an array that is sorted in ascending order, return a </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> object that is height-balanced. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Closest</span><span style="font-size:0.86em"> Common Ancestor</span></p><p style="line-height:115%"><span>Given a </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span> and two contained values, return the</span><span> value of the</span><span> </span><span style="font-style:italic">closest</span><span style="font-style:italic"> common ancestor</span><span> node</span><span>. For each node, the chain up to </span><span class="CodeSnippet" style="font-family:Times, serif">root</span><span> (including </span><span class="CodeSnippet" style="font-family:Times, serif">self</span><span>) represents that node’s ancestry. Return </span><span>the </span><span>value of the node in both ancestor chains that is closest to both. </span></p><p class="Normal1"><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 11 – Trees</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p></div></body></html>