<?xml version="1.0" encoding="utf-8" standalone="no"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" /><meta http-equiv="Content-Style-Type" content="text/css" /><meta name="description" content="Computer Science Algorithms Data Structures JavaScript JS" /><meta name="generator" content="Aspose.Words for .NET 13.6.0.0" /><title>Algorithms_Collection</title><link href="item_083.css" type="text/css" rel="stylesheet" /></head><body><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><h2 id="navPoint_96"><span>Heap Data Structure</span></h2><p><span>The mythical </span><span style="font-style:italic">manticore</span><span> had lion’s body, human head, and scorpion tail. Priority queues are commonly constructed with </span><span style="font-style:italic">minheap</span><span style="font-style:italic">s</span><span>, with similarly unusual characteristics (not heap where memory allocations occur, although regrettably the same word). Not to be outdone by manticores, heaps act like queues, manage data like trees, and are stored in arrays. Rather than extraordinary speed in a few aspects, heaps strike a balance: great insertion, good deletion, and great extraction (in monotonic priority order). </span></p><p><span>&#xa0;</span></p><p><span>Ho</span><span>w does this creature do it? </span><span>A</span><span> heap isn’t fully sorted</span><span>. It knows the lowest value, and can </span><span>quickly rearrange to stay “sorted just enough” for </span><span>the next ask</span><span>. Insertion similarly </span><span>does </span><span style="font-style:italic">just enough</span><span> to stay </span><span>“</span><span>somewhat sorted</span><span>”</span><span> without extra work. </span><span>T</span><span>hese “lazy” </span><span>heaps</span><span> work this way</span><span>: </span><span style="font-style:italic">f</span><span style="font-style:italic">irst</span><span>, data are arranged in binary nodes. </span><span style="font-style:italic">Second</span><span>, minheap node must have a value less / equal to its children’s. </span><span style="font-style:italic">Third</span><span>, minheaps are </span><span style="font-style:italic">complete</span><span> trees: all nodes have two children except at deepest level, where nodes populate from leftmost extending right. That’s it! Here we assume</span><span> a</span><span> </span><span style="font-style:italic">minheap</span><span>, </span><span>although we easily invert rules for </span><span style="font-style:italic">maxheap</span><span>. The only behavior difference: maxheaps extract values largest to smallest, not lowest-first. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>Here’s the next interesting detail: instead of using actual binary tree nodes, a minheap puts values into an array, using array indices to track parent-child relationships between values. Specifically, value at index N has children at indices 2N and 2N+1, and its parent can always be found at N/2. The root of the heap is located at index 1 (index 0 usually holds some other value). Thus, tree traversal from arbitrary nodes is quick. With this in mind, four of the basic data structure methods (</span><span class="CodeSnippet" style="font-family:Times, serif">size()</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">isEmpty()</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">top()</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">contains(val)</span><span>) are trivial. The performance of </span><span class="CodeSnippet" style="font-family:Times, serif">contains(val)</span><span> is horrid (effectively, it must search the entire underlying array). The </span><span class="CodeSnippet" style="font-family:Times, serif">insert()</span><span> and </span><span class="CodeSnippet" style="font-family:Times, serif">extract()</span><span> methods are more interesting. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>For </span><span class="CodeSnippet" style="font-family:Times, serif">insert(val)</span><span>, we know that our tree’s size will grow by one. Because our tree is </span><span style="font-style:italic">complete</span><span>, we know where this new </span><span style="font-style:italic">node</span><span> will be added (our </span><span class="CodeSnippet" style="font-family:Times, serif">Array.</span><span class="CodeSnippet" style="font-family:Times, serif">length</span><span> will grow by one). Although that likely isn’t where it belongs, we put the </span><span style="font-style:italic">new </span><span>value</span><span> there to start. We then undergo a “promote” process for node, comparing it to parent. If value is less than parent’s, we swap them and try to promote it again (comparing to its new post-swap parent). Once it can no longer be promoted, insertion is complete. </span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1" style="line-height:115%"><span>Build the following methods on a new class called a </span><span class="CodeSnippet" style="font-family:Times, serif">MinHeap</span><span>:</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Heap</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> C</span><span style="font-size:0.86em">onstructor</span></p><p style="line-height:115%"><span>Create a </span><span class="CodeSnippet" style="font-family:Times, serif">MinHeap</span><span> constructor function.</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Heap</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> S</span><span style="font-size:0.86em">ize</span></p><p style="line-height:115%"><span>Return the number of values in the </span><span class="CodeSnippet" style="font-family:Times, serif">MinHeap</span><span>.</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Heap</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> C</span><span style="font-size:0.86em">ontains</span></p><p><span>Return whether a given val is within the heap. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Heap</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> I</span><span style="font-size:0.86em">s Empty</span></p><p><span>Return whether the heap is empty. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Heap</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> T</span><span style="font-size:0.86em">op</span></p><p><span>Return (not remove) the heap’s minimum value. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Heap</span><span style="font-size:0.86em">:</span><span style="font-size:0.86em"> I</span><span style="font-size:0.86em">nsert</span></p><p><span>Add the given value to our heap.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 13</span><span> – Sets and Priority Queues</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p style="line-height:115%"><span>Let us continue our development of the </span><span class="CodeSnippet" style="font-family:Times, serif">MinHeap</span><span> data structure. Previously, we developed the ability to add elements. Now we will build a method to remove the top element – we’ll call it </span><span class="CodeSnippet" style="font-family:Times, serif">extract()</span><span>. </span></p><p><span>&#xa0;</span></p><p><span>For this discussion, keep in mind that although we are storing the element values in an array, we are still thinking about the collection of values as a binary tree. With this in mind, below I refer to values and nodes. By nodes, I just mean the array index where the value is found. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>For </span><span class="CodeSnippet" style="font-family:Times, serif">extract()</span><span>, we know that our tree size will shrink by one node. Because it is always a </span><span style="font-style:italic">complete</span><span> tree, we know that the node to be removed is the </span><span style="font-style:italic">last</span><span> node. In other words, our array will become shorter, by one. We also know which </span><span style="font-style:italic">value</span><span> needs to be removed from our array, and it is the </span><span style="font-style:italic">first </span><span>value, not the last value</span><span>. To </span><span>use a metaphor, we remove the first person, and the last chair. </span><span>So,</span><span> our challenge, when we extract a value from our heap, is how to </span><span style="font-style:italic">minimally</span><span> rearrange values in the tree so that all the remaining nodes are occupied by the remaining values, in a way that satisfies all the heap rules. Doing this in a minimal way is the hallmark of a heap. </span></p><p><span>&#xa0;</span></p><p><span>We start by considering the last value in the heap – the one sitting in the array index we want to remove. We give that value an unusual opportunity: we move it to the </span><span style="font-style:italic">root </span><span>for a short time. From there, we will put the value through a “demote” process to shift it downward in the tree to a more suitable spot. What does this “demote” process entail? After swapping the value into the root spot, we first compare it to its two new children. If either of them has a lower value than it does, we swap it with the lower one, then repeat this “demote” process with that same value in its new spot, until it has no children with lower values (this might not happen until it has no children at all!). Once it can no longer be demoted, the extraction process is complete. </span></p><p><span>&#xa0;</span></p><p style="line-height:115%"><span>With </span><span class="CodeSnippet" style="font-family:Times, serif">e</span><span class="CodeSnippet" style="font-family:Times, serif">xtract()</span><span>, our basic data structure implementation is complete. Additionally, we would like the ability to pass in an array and have the Heap adopt that array as its own, quickly repairing it to a state of compliance with the Heap rules. First, change the Heap constructor to optionally accept an array. Also create the </span><span class="CodeSnippet" style="font-family:Times, serif">h</span><span class="CodeSnippet" style="font-family:Times, serif">eapify</span><span> method that accepts and repairs this array a</span><span>fter the Heap has been created.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Heap: E</span><span style="font-size:0.86em">xtract</span></p><p style="line-height:115%"><span>Create a </span><span class="CodeSnippet" style="font-family:Times, serif">MinHeap</span><span> method that removes the heap’s minimum value and returns it. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Heap</span><span style="font-size:0.86em">: Heap</span><span style="font-size:0.86em">ify</span><span style="font-size:0.86em"> Array</span></p><p style="line-height:115%"><span>Create a heap method that accepts an array as its own, and turns it into a rule-abiding </span><span class="CodeSnippet" style="font-family:Times, serif">MinHeap</span><span>.</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Heap Sort</span></p><p style="line-height:115%"><span>Lance discovers with glee that</span><span> if one heapifies an unsorted array</span><span>,</span><span> then extracts values, the array is sorted in </span><span class="CodeSnippet" style="font-family:Times, serif">O(NlogN</span><span class="CodeSnippet" style="font-family:Times, serif">)</span><span> time </span><span>–</span><span> as</span><span> fast as q</span><span>uick</span><span> s</span><span>ort </span><span>or m</span><span>erge</span><span> s</span><span>ort, the </span><span>usual </span><span>winners in generalized sorting! </span><span>He views this as solid proof that the </span><span>Heap truly is “</span><span>the </span><span>crown pri</span><span>nce of data structures.” Write a</span><span> </span><span style="font-style:italic">standalone</span><span> function</span><span> </span><span class="CodeSnippet" style="font-family:Times, serif">heapSort(arr)</span><span> that accepts an unsorted array and uses a heap to sort it. </span></p><p><span style="font-weight:bold">&#xa0;</span></p><p><span style="font-weight:bold">Second:</span><span> do this in-place without creating a second array</span><span>.</span><span> </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 13</span><span> – Sets and Priority Queues</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Median of Data Stream</span></p><p style="line-height:115%"><span>With a separate function </span><span class="CodeSnippet" style="font-family:Times, serif">addValue(val)</span><span>, you will be given a continuous stream of data, one value at a time. At any moment, with reasonable performance you need to be able to return the median value. (What is reasonable performance?) Recall that the median of an even number of elements is the average of the two middle values. </span></p><p><span>&#xa0;</span></p><p><span>Before next chapter, here are a few other Queue/Stack problems </span><span>to keep you thinking. Have fun! </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Queue </span><span style="font-size:0.86em">from</span><span style="font-size:0.86em"> Two Stacks</span></p><p><span>Using only </span><span>S</span><span>tack objects (</span><span>not</span><span> other data structures such as linked</span><span> lists or arrays), implement a Q</span><span>ueue. </span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><br style="mso-column-break-before:always; clear:both" /><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Priority Queue </span><span style="font-size:0.86em">from</span><span style="font-size:0.86em"> Two Stacks</span></p><p><span>Using only S</span><span>tack objects (</span><span>not</span><span> other data structures such as lists or</span><span> arrays), implement a Priority Q</span><span>ueue. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Comparing Stacks/Queues </span><span style="font-size:0.86em">to</span><span style="font-size:0.86em"> Other Data Structures</span></p><p style="line-height:115%"><span>By now we have studied a few different data structures: array, </span><span class="CodeSnippet" style="font-family:Times, serif">SList</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">DList</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">BST</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">SL</span><span class="CodeSnippet" style="font-family:Times, serif">Queue</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">C</span><span class="CodeSnippet" style="font-family:Times, serif">irQueue</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">ArrStack</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">D</span><span class="CodeSnippet" style="font-family:Times, serif">eque</span><span>, </span><span class="CodeSnippet" style="font-family:Times, serif">PriQ</span><span class="CodeSnippet" style="font-family:Times, serif">ueue</span><span>. Eac</span><span>h of these could be built as a </span><span style="font-style:italic">set</span><span> instead of a </span><span style="font-style:italic">m</span><span style="font-style:italic">ultiset</span><span> (rejecting duplicate values instead of accepting them). We will not require you to build all the possible variants, but below we list them for completeness. Those that are bolded are ones you’ve already built previously; those underlined are highly recommended. In most cases, creating these will require only small adjustments to code you’ve already written. </span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><span style="font-weight:bold">Array (random-access multiset)</span></p><p><span style="text-decoration:underline">Array without duplicates (random-access set)</span></p><p style="font-size:0.91em; line-height:115%"><span style="font-weight:bold">&#xa0;</span></p><p><span style="font-weight:bold">SList (forward-iterated insertable multiset)</span></p><p><span style="text-decoration:underline">SList without duplicates (forward-iterated insertable set)</span></p><p><span>&#xa0;</span></p><p><span style="font-weight:bold">DList (double-iterated insertable multiset)</span></p><p><span>DList without duplicates (double-iterated insertable set)</span></p><p style="font-size:0.91em; line-height:115%"><span style="font-weight:bold">&#xa0;</span></p><p><span style="font-weight:bold">Binary Search Tree (ordered multiset)</span></p><p><span style="font-weight:bold">Binary Search Tree without duplicates (ordered set)</span></p><p><br style="mso-column-break-before:always; clear:both" /><span style="font-weight:bold">SLQueue (sequential multiset)</span></p><p><span>SLQueue without duplicates (sequential set)</span></p><p><span>&#xa0;</span></p><p><span style="font-weight:bold">CirQueue (sequential multiset)</span></p><p><span>CirQueue without duplicates (sequential set)</span></p><p style="font-size:0.91em; line-height:115%"><span style="font-weight:bold">&#xa0;</span></p><p><span style="font-weight:bold">SLStack (sequential multiset)</span></p><p><span>SLStack without duplicates (sequential set)</span></p><p><span style="text-decoration:underline">ArrStack (sequential multiset)</span></p><p><span>ArrStack without duplicates (sequential set)</span></p><p style="font-size:0.91em; line-height:115%"><span style="font-weight:bold">&#xa0;</span></p><p><span style="font-weight:bold">Deque (double-sequential multiset)</span></p><p><span>Deque without duplicates (double-sequential set)</span></p><p style="font-size:0.91em; line-height:115%"><span style="font-weight:bold">&#xa0;</span></p><p><span style="font-weight:bold">PriQueue (forward-ordered multiset)</span></p><p><span style="text-decoration:underline">PriQueue without duplicates (forward-ordered set)</span></p></div><div style="clear:both; mso-break-type:section-break; page-break-before:auto"><p><span style="font-weight:bold">Next chapter we’ll build these:</span></p><p><span style="text-decoration:underline">Associative</span><span style="text-decoration:underline"> </span><span style="text-decoration:underline">Arr</span><span style="text-decoration:underline">ay</span><span style="text-decoration:underline"> (unordered multiset)</span></p><p><span style="text-decoration:underline">Associative</span><span style="text-decoration:underline"> </span><span style="text-decoration:underline">Arr</span><span style="text-decoration:underline">ay</span><span style="text-decoration:underline"> without duplicates (unordered set)</span><span> </span></p><p><br style="page-break-before:always; clear:both" /></p><p class="PageHeader"><span>Chapter 13 – Sets and Priority Queues</span></p><p class="Normal1" style="border-top-color:#000000; border-top-style:solid; border-top-width:0.5pt; padding-top:1pt"><span>&#xa0;</span></p><p><span>With </span><span>short answer question</span><span>s</span><span>, you </span><span>can </span><span>demonstrate </span><span style="font-style:italic">technical depth</span><span> </span><span>as well as</span><span> </span><span style="font-style:italic">clarity of communication</span><span>. </span></p><p><span>How would you answer the following, if asked in an interview?</span></p><p class="Challenge" style="font-size:1.27em; line-height:115%"><span style="font-family:Times, serif; text-decoration:none"></span><span style="color:#000000; font-size:0.86em; text-decoration:none"> </span><span style="font-size:0.86em">Short Answer Questions: </span><span style="font-size:0.86em">Sets and Priority Queues</span></p><p class="Normal1"><span style="font-weight:bold">What is a Set data structure? What is an example of this, in the natural world? </span></p><p class="Normal1"><span style="font-weight:bold">By default, is a set Ordered or Unordered? </span></p><p class="Normal1"><span style="font-weight:bold">&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">What is a Map data structure? What is an example of this, in the natural world? </span></p><p class="Normal1"><span style="font-weight:bold">Generally, how do sets and maps differ?</span></p><p class="Normal1"><span style="font-weight:bold">&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">By default, do maps allow multiple keys with the same value? </span></p><p class="Normal1"><span style="font-weight:bold">Generally, how are sets and multisets different?</span></p><p class="Normal1"><span>&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">What is </span><span style="font-weight:bold">one </span><span style="font-weight:bold">good </span><span style="font-weight:bold">way to implement </span><span style="font-weight:bold">an unordered map?</span></p><p class="Normal1"><span style="font-weight:bold">What is </span><span style="font-weight:bold">one good way to implement </span><span style="font-weight:bold">an ordered multimap? </span></p><p class="Normal1"><span style="font-weight:bold">What is </span><span style="font-weight:bold">one good way to implement </span><span style="font-weight:bold">an ordered set?</span></p><p class="Normal1"><span style="font-weight:bold">What is </span><span style="font-weight:bold">one good way to implement </span><span style="font-weight:bold">an unordered multiset? </span></p><p class="Normal1"><span style="font-weight:bold">&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">What i</span><span style="font-weight:bold">s a H</span><span style="font-weight:bold">eap? How do </span><span style="font-weight:bold">they</span><span style="font-weight:bold"> work generally? </span></p><p class="Normal1"><span style="font-weight:bold">What</span><span style="font-weight:bold"> are the advantages of using a H</span><span style="font-weight:bold">eap? </span><span style="font-weight:bold">What are the disadvantages? </span></p><p class="Normal1"><span style="font-weight:bold">What happens ‘under the ho</span><span style="font-weight:bold">od’ when a value is added to a H</span><span style="font-weight:bold">eap? </span></p><p class="Normal1"><span style="font-weight:bold">Likewise, w</span><span style="font-weight:bold">hat</span><span style="font-weight:bold">’</span><span style="font-weight:bold">s the </span><span style="font-weight:bold">sequence of events</span><span style="font-weight:bold"> </span><span style="font-weight:bold">when removing </span><span style="font-weight:bold">a H</span><span style="font-weight:bold">eap value?</span></p><p class="Normal1"><span style="font-weight:bold">How </span><span style="font-weight:bold">can</span><span style="font-weight:bold"> I check whether a H</span><span style="font-weight:bold">eap is valid? </span></p><p class="Normal1"><span style="font-weight:bold">What is the difference between a MinHeap and a MaxHeap? </span></p><p class="Normal1"><span style="font-weight:bold">&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">For </span><span style="font-weight:bold">a M</span><span style="font-weight:bold">inHeap</span><span style="font-weight:bold"> data structure</span><span style="font-weight:bold"> that has the following methods – </span><span style="font-weight:bold">push, pop</span><span style="font-weight:bold">, min, max, </span><span style="font-weight:bold">removeMin, removeMax, contains, prevVal, </span><span style="font-weight:bold">nextVal, size – which of these are relatively </span><span style="font-style:italic; font-weight:bold">fast</span><span style="font-weight:bold">? </span><span style="font-style:italic; font-weight:bold">How</span><span style="font-weight:bold"> fast? </span></p><p class="Normal1"><span style="font-weight:bold">Conversely, which of these methods would be considered relatively </span><span style="font-weight:bold">slow?</span><span style="font-weight:bold"> </span><span style="font-style:italic; font-weight:bold">How</span><span style="font-weight:bold"> slow?</span></p><p class="Normal1"><span style="font-weight:bold">When would a heap be considered</span><span style="font-weight:bold"> </span><span style="font-weight:bold">‘</span><span style="font-weight:bold">full</span><span style="font-weight:bold">’</span><span style="font-weight:bold">?</span><span style="font-weight:bold"> </span></p><p class="Normal1" style="font-size:1.27em; line-height:115%"><span style="font-family:Wingdings, serif">&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">What is a Priority Q</span><span style="font-weight:bold">ue</span><span style="font-weight:bold">ue, and is it at all different than a H</span><span style="font-weight:bold">eap? How? </span></p><p class="Normal1"><span style="font-weight:bold">When would you use a BST instead of a Priority Queue? </span></p><p class="Normal1"><span style="font-weight:bold">When would you use a ‘regular’ Queue instead of a Priority Queue? </span></p><p class="Normal1"><span style="font-weight:bold">&#xa0;</span></p><p class="Normal1"><span style="font-weight:bold">What is HeapSort, and how does it work? </span></p><p class="Normal1"><span style="font-weight:bold">What are the Big-O requirements (run-time and space) for HeapSort? </span></p><p><br style="page-break-before:always; clear:both" /></p></div></body></html>